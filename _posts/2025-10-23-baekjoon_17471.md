---
title: "[백준 17142] 연구소 3 (조합 + BFS) - Java"
date: 2025-10-23
categories: [Baekjoon, Java]
tags: [BFS, 조합, 완전탐색, 백트래킹, 시뮬레이션, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 🧪 백준 17142 - 연구소 3 (Java)

---

## 📘 문제 설명

연구소의 크기 `N × N`과 바이러스의 개수 `M`이 주어진다.  
연구소 내부에는 벽(1), 빈 칸(0), 그리고 바이러스(2)가 존재한다.  
`M`개의 바이러스를 활성화시켜 **모든 빈 칸을 최소 시간 내 감염시키는** 문제이다.

모든 빈 칸을 감염시키지 못한다면 `-1`을 출력해야 한다.

---

## 💻 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class baekjoon17142 {
    static int N, M;  // 실험실 크기 N과 바이러스 개수 M
    static int[][] lab;  // 실험실 맵을 나타내는 2D 배열
    static List<int[]> virusLocations = new ArrayList<>();  // 바이러스가 있는 위치를 저장하는 리스트
    static int[] dx = {-1, 1, 0, 0};  // 상, 하 방향으로 이동하기 위한 배열
    static int[] dy = {0, 0, -1, 1};  // 좌, 우 방향으로 이동하기 위한 배열
    static int minTime = Integer.MAX_VALUE;  // 최소 시간 (초기값은 무한대)

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 실험실 크기 N과 바이러스 개수 M 입력
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        lab = new int[N][N];  // 실험실 맵 초기화
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < N; j++) {
                lab[i][j] = Integer.parseInt(st.nextToken());  // 실험실 각 칸의 상태 입력
                if (lab[i][j] == 2) {
                    // 바이러스 위치를 리스트에 추가
                    virusLocations.add(new int[]{i, j});
                }
            }
        }

        // 바이러스를 선택할 수 있는 모든 경우의 조합을 구하고, 각각에 대해 BFS를 실행
        combination(0, 0, new int[M]);

        // 결과 출력: 최소 시간이 갱신되지 않으면 -1을 출력 (불가능한 경우)
        if (minTime == Integer.MAX_VALUE) {
            System.out.println(-1);
        } else {
            System.out.println(minTime);
        }
    }

    // 조합을 이용해 바이러스 위치를 M개 선택하는 함수
    static void combination(int start, int depth, int[] selected) {
        // M개 바이러스를 선택한 경우, BFS 실행
        if (depth == M) {
            bfs(selected);
            return;
        }

        // 바이러스를 조합하여 선택 (백트래킹 방식)
        for (int i = start; i < virusLocations.size(); i++) {
            selected[depth] = i;  // 선택된 바이러스의 인덱스 기록
            combination(i + 1, depth + 1, selected);  // 다음 깊이로 진행
        }
    }

    // BFS를 통해 바이러스가 퍼지는 시간을 계산하는 함수
    static void bfs(int[] selected) {
        int[][] visited = new int[N][N];  // 방문 여부를 나타내는 배열
        Queue<int[]> queue = new LinkedList<>();  // BFS를 위한 큐
        int time = 0;  // 최소 시간을 계산할 변수

        // 선택된 바이러스들을 큐에 넣고 시작
        for (int i = 0; i < M; i++) {
            int[] virus = virusLocations.get(selected[i]);
            int x = virus[0];
            int y = virus[1];
            queue.offer(new int[]{x, y, 0});  // (x, y) 좌표와 시간 0을 큐에 넣음
            visited[x][y] = 1;  // 바이러스가 있는 칸은 방문 처리
        }

        // BFS 수행
        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int x = current[0];
            int y = current[1];
            int t = current[2];  // 현재 시간

            // 상하좌우로 이동하면서 전파
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];  // 다음 x 좌표
                int ny = y + dy[i];  // 다음 y 좌표

                // 범위 체크 및 벽이 아닌 곳만 이동
                if (nx >= 0 && nx < N && ny >= 0 && ny < N && visited[nx][ny] == 0 && lab[nx][ny] != 1) {
                    visited[nx][ny] = 1;  // 방문 처리
                    // 만약 빈 공간(0)이라면 시간 갱신 후 큐에 추가
                    if (lab[nx][ny] == 0) {
                        queue.offer(new int[]{nx, ny, t + 1});  // (nx, ny)와 새로운 시간 t+1을 큐에 넣음
                        time = Math.max(time, t + 1);  // 가장 오래 걸린 시간 갱신
                    } else {
                        queue.offer(new int[]{nx, ny, t + 1});  // 벽(1)은 아니지만, 바이러스 전파가 필요하므로 큐에 넣음
                    }
                }
            }
        }

        // 모든 빈 칸이 감염되었는지 확인하고, 가능하다면 최소 시간 갱신
        if (checkAllInfected(visited)) {
            minTime = Math.min(minTime, time);  // 최소 시간 계산
        }
    }

    // 모든 빈 칸이 감염되었는지 확인하는 함수
    static boolean checkAllInfected(int[][] visited) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (lab[i][j] == 0 && visited[i][j] == 0) {  // 빈 칸이 아직 감염되지 않았다면
                    return false;  // 감염되지 않은 빈 칸이 있으면 false
                }
            }
        }
        return true;  // 모든 빈 칸이 감염되었으면 true
    }
}

```

---

## ⚙️ 핵심 로직 정리

| 구분                 | 설명                                             |
| -------------------- | ------------------------------------------------ |
| 조합 (Combination)   | 전체 바이러스 중 M개를 선택하여 활성화           |
| BFS (너비 우선 탐색) | 선택된 바이러스에서 동시에 퍼지게 함             |
| 시간 계산            | 빈 칸(0)이 감염될 때의 최대 시간 추적            |
| 검증 단계            | 모든 빈 칸이 감염되었는지 확인 후 최소 시간 갱신 |

---

## 🧩 주요 메서드 설명

| 메서드명             | 설명                                  |
| -------------------- | ------------------------------------- |
| `combination()`      | 바이러스 조합 선택 (백트래킹 방식)    |
| `bfs()`              | BFS를 통해 감염 퍼뜨리기 및 시간 계산 |
| `checkAllInfected()` | 모든 빈 칸이 감염되었는지 확인        |

---

## 💾 사용된 자료구조

| 자료구조       | 설명                          |
| -------------- | ----------------------------- |
| `List<int[]>`  | 바이러스 좌표 저장            |
| `Queue<int[]>` | BFS 탐색용 큐                 |
| `int[][]`      | 실험실 상태 및 방문 여부 저장 |
| `int[]`        | 선택된 바이러스 인덱스 저장   |

---

## ⏱️ 시간 복잡도 분석

- **조합:** `O(C(V, M))`
- **BFS 탐색:** `O(N²)`
- **전체 시간 복잡도:** `O(C(V, M) × N²)`  
  👉 `N ≤ 50`, `V ≤ 10`이므로 충분히 해결 가능한 범위입니다.

---

## 💡 구현 시 주의할 점

- 비활성 바이러스 칸(2)도 전파는 가능하지만 시간 계산에는 포함되지 않음
- `checkAllInfected()`를 통해 감염되지 않은 빈 칸을 반드시 검사해야 함
- 최소 시간을 갱신할 때는 `minTime = Math.min(minTime, time)`으로 비교

---

## 🧠 접근 방법

1. **모든 바이러스 조합 생성** → Combination으로 M개 활성 바이러스 선택
2. **각 조합마다 BFS 수행** → 선택된 바이러스들이 동시에 퍼짐
3. **모든 빈 칸 감염 여부 확인**
4. **감염 불가능 시 -1 출력, 최소 시간 출력**

---

## 💬 느낀점

이 문제는 **“조합 + BFS”**의 대표적인 응용 문제입니다.  
단순 BFS보다 한 단계 더 깊은 사고가 필요했고,  
**비활성화된 바이러스 칸은 감염될 수 있지만 시간에 포함되지 않는다**는 점이 특히 구현 포인트였습니다.

하지만 BFS의 본질과 완전탐색(조합)의 결합을 연습하기에 매우 좋은 문제였습니다.  
이 문제를 통해 **“경우의 수 탐색 + 시뮬레이션 로직의 조합”**을 명확히 이해할 수 있었습니다.
