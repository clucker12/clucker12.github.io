---
title: "[백준 1107] 리모컨 문제 풀이 - Java"
date: 2025-09-18
categories: [Baekjoon, Java]
tags: [브루트포스, 구현, 완전탐색, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 🔑 문제 설명

- **문제 번호**: 1107
- **문제 이름**: 리모컨
- **요약**: 0-9 숫자 버튼과 +, - 버튼이 있는 리모컨으로 목표 채널 N으로 이동하는 최소 버튼 누름 횟수를 구한다.
- 시작 채널은 100.

---

# 💻 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon1107 {
    // 목표 채널 (N), 고장난 버튼 수 (M)
    static int N, M;

    // 고장난 버튼 정보를 저장하는 배열
    // 예: errNum[3] = true → 버튼 3은 고장
    static boolean[] errNum = new boolean[10];

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 1. 목표 채널 N 입력
        N = Integer.parseInt(br.readLine());

        // 2. 고장난 버튼 수 M 입력
        M = Integer.parseInt(br.readLine());

        // 3. 고장난 버튼들 입력받기
        if (M > 0) {
            st = new StringTokenizer(br.readLine());
            for (int i = 0; i < M; i++) {
                int n = Integer.parseInt(st.nextToken());
                errNum[n] = true; // 해당 숫자 버튼이 고장남
            }
        }

        // 4. 초기 최소 버튼 수는 (+/-)만 사용해서 이동할 경우
        // 현재 채널 100에서 목표 채널 N까지 거리
        int min = Math.abs(N - 100);

        // 5. 0 ~ 999,999까지 모든 채널 번호를 시도해보며
        // 숫자 버튼으로 만들 수 있는 채널을 찾음
        for (int i = 0; i <= 999999; i++) {
            int len = dfs(i); // 해당 채널 번호를 숫자 버튼으로 누를 수 있는지 확인
            if (len > 0) {
                // 숫자로 입력한 채널 i에서 목표 채널 N까지 거리 + 숫자 누른 횟수
                int cnt = Math.abs(i - N) + len;

                // 최소 횟수 갱신
                min = Math.min(cnt, min);
            }
        }

        // 6. 최소 횟수 출력
        System.out.println(min);
    }

    /**
     * dfs 함수: 특정 채널 번호 n을 숫자 버튼만으로 누를 수 있는지 검사
     * @param n: 시도할 채널 번호
     * @return 누를 수 있으면 자릿수(길이), 누를 수 없으면 0
     */
    static int dfs(int n) {
        // n이 0일 경우 따로 처리
        if (n == 0) {
            return errNum[0] ? 0 : 1; // 0번 버튼이 고장났으면 0, 아니면 1자리
        }

        int len = 0;

        // 각 자리수의 숫자가 고장났는지 확인
        while (n > 0) {
            if (errNum[n % 10]) return 0; // 한 자리라도 고장났으면 불가능
            n /= 10;
            len++; // 자릿수 카운트
        }

        return len; // 입력 가능한 숫자의 자리 수 (버튼 누름 횟수)
    }
}

```

---

# 💡 접근 방법

1. **초기값 설정**: +와 - 버튼만 사용했을 때의 최소 횟수는 `|N - 100|`.
2. **브루트포스 탐색**: 0부터 999,999까지 모든 채널 번호를 시도하며, 고장난 버튼 없이 입력 가능한지 확인.
3. **최소값 갱신**: 숫자로 이동 후 +,-로 조정한 횟수와 현재 최소값 비교.

---

# 📜 핵심 코드

```java
int min = Math.abs(N - 100);
for (int i = 0; i <= 999999; i++) {
    int len = dfs(i);
    if (len > 0) {
        int cnt = Math.abs(i - N) + len;
        min = Math.min(cnt, min);
    }
}
System.out.println(min);
```

- 0 ~ 999999까지 탐색: 채널은 최대 6자리까지 가능.

---

# 🧩 주요 메서드 및 로직

### `dfs(int n)`

- **역할**: 숫자 버튼만으로 `n`을 누를 수 있는지 확인 후 자릿수 반환.
- **로직**: 각 자리수가 고장난 버튼인지 검사. 하나라도 고장나면 0 반환.

---

# 🗂️ 사용 자료구조

- **boolean[] errNum (길이 10)**: 각 숫자 버튼의 고장 여부 저장.
- **기본 반복문 + 완전탐색**: 0 ~ 999999 채널 번호를 전수 조사.

---

# ⏱️ 시간 복잡도

- **완전 탐색**: 최대 1,000,000개의 채널 확인.
- 각 채널마다 최대 6자리 검사 → **O(1,000,000 × 6) ≈ O(6,000,000)**.
- 충분히 1초 안에 동작 가능.

---

# 🧐 중요 코드 설명

- `min = Math.abs(N - 100)`: +,- 버튼만 이용할 경우 초기 최소값 설정.
- `dfs(i)`: i가 고장난 버튼 없이 입력 가능한지 검사.
- `Math.min(cnt, min)`: 현재 최소 횟수와 비교 후 갱신.

---

# 💭 느낀점

처음엔 단순히 `|N-100|`만 계산했지만, 숫자 버튼을 조합해 직접 입력 후 +,-로 이동하는 것이 더 빠를 수 있음을 깨달았다.  
브루트포스를 적용하면 간단히 해결되는 문제였다. 완전 탐색을 통한 모든 경우의 수 확인이 얼마나 강력한지 다시 느꼈다.

---
