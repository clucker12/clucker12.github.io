---
title: "[백준 14889] - 스타트와 링크 - Java 풀이"
date: 2025-08-26
categories: [Baekjoon, Java]
tags: [백트래킹, 브루트포스, DFS, 구현, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 🏐 백준 14889 - 스타트와 링크

## 📌 문제 설명

N명의 사람을 두 팀으로 나누었을 때, 각 팀의 능력치 차이가 최소가 되도록 나누는 문제입니다.  
모든 능력치 값이 주어지고, `스타트 팀`과 `링크 팀`의 능력치 합의 차이가 최소가 되도록 구해야 합니다.

---

## 💻 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon14889 {
    // 총 인원 수 (짝수)
    static int N;

    // 능력치 배열
    static int[][] S;

    // 스타트 팀 여부를 표시하는 배열
    static boolean[] visited;

    // 능력치 차이의 최소값 저장
    static int min = Integer.MAX_VALUE;

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 인원 수 입력
        N = Integer.parseInt(br.readLine());

        // 능력치 배열 및 visited 배열 초기화
        S = new int[N][N];
        visited = new boolean[N];

        // 능력치 입력 받기
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < N; j++) {
                S[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        // 팀 나누기 시작
        maketeam(0, 0);

        // 최소 능력치 차이 출력
        System.out.println(min);
    }

    // 팀을 나누는 함수 (재귀적으로 N/2명 선택)
    static void maketeam(int idx, int depth) {
        // N/2명을 선택했다면 계산
        if (depth == N / 2) {
            calculate();
            return;
        }

        // 조합을 위해 idx부터 N까지 반복
        for (int i = idx; i < N; i++) {
            if (!visited[i]) {
                visited[i] = true;  // i번 사람을 스타트 팀으로 선택
                maketeam(i + 1, depth + 1);  // 다음 사람 선택
                visited[i] = false; // 백트래킹
            }
        }
    }

    // 두 팀의 능력치 차이 계산
    static void calculate() {
        int start = 0; // 스타트 팀 능력치 합
        int link = 0;  // 링크 팀 능력치 합

        // 모든 쌍(i, j)을 돌면서 같은 팀끼리만 능력치 더하기
        for (int i = 0; i < N - 1; i++) {
            for (int j = i + 1; j < N; j++) {
                // 둘 다 visited → 스타트 팀
                if (visited[i] && visited[j]) {
                    start += S[i][j] + S[j][i];
                }
                // 둘 다 미방문 → 링크 팀
                else if (!visited[i] && !visited[j]) {
                    link += S[i][j] + S[j][i];
                }
            }
        }

        // 두 팀의 능력치 차이
        int sol = Math.abs(start - link);

        // 최소값 갱신
        min = Math.min(min, sol);
    }
}
```

---

## 🔑 접근 방법

- 이 문제는 **백트래킹 + 브루트포스** 조합으로 해결됩니다.
- N명이 있을 때, N/2명을 스타트 팀으로 뽑으면 나머지는 자동으로 링크 팀이 됩니다.
- 따라서 모든 경우의 수를 탐색해 최소 능력치 차이를 구하는 방식입니다.

---

## 🛠 주요 메서드 & 핵심 로직

- **`maketeam(idx, depth)`**
  - `idx`: 선택을 시작할 인덱스
  - `depth`: 현재까지 뽑은 팀원의 수
  - 재귀적으로 N/2명을 선택하고, 다 뽑으면 `calculate()` 호출
- **`calculate()`**
  - 방문 배열 `visited`를 이용해 두 팀을 나눈 뒤, 능력치 합을 계산
  - 두 팀 능력치 차이의 최소값을 갱신

---

## ⏱ 시간 복잡도 분석

- 팀을 나누는 경우의 수는 **조합(N, N/2)** → `O(2^N)`에 가깝습니다.
- 각 조합마다 능력치 차이를 계산할 때 `O(N^2)` 시간이 걸립니다.
- 따라서 최종 시간 복잡도는 **O(N^2 \* 2^N)** 입니다.
- N ≤ 20 이므로, 충분히 가능.

---

## 💡 사용한 자료구조

- `boolean[] visited`: 특정 인원이 스타트 팀인지 여부를 저장
- `int[][] S`: 능력치 저장을 위한 2차원 배열

---

## 🎯 마무리 & 느낀점

이 문제는 단순한 브루트포스가 아닌, **백트래킹**을 통해 탐색 공간을 줄이는 것이 핵심이었습니다.  
처음에는 단순히 모든 조합을 다 탐색하는 방식으로 접근했지만, 백트래킹을 활용해 **불필요한 탐색을 줄이는 과정**이 중요하다는 것을 깨달았습니다.  
DFS와 유사한 방식으로 문제를 해결하면서, **조합 문제**와 **탐색 최적화**에 대해 더 깊이 이해할 수 있었습니다.  
앞으로 비슷한 문제를 접할 때, "브루트포스로 다 해보기 전에 백트래킹으로 탐색 공간을 줄일 수 없을까?"라는 생각을 먼저 떠올릴 수 있을 것 같습니다.
