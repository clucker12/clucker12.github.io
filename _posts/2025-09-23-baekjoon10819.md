---
title: "[백준 10819] 차이를 최대로 문제 풀이 - Java"
date: 2025-09-23
categories: [Baekjoon, Java]
tags: [백트래킹, 완전탐색, 순열, DFS, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 문제 개요

주어진 배열 **A**의 원소들을 재배열하여  
\|A[0] - A[1]\| + \|A[1] - A[2]\| + … + \|A[N-2] - A[N-1]\|  
의 **최댓값**을 구하는 문제.

- **입력**: 정수 N (3 ≤ N ≤ 8), 배열 A의 원소 N개
- **출력**: 위 식의 최댓값

---

## 접근 방법

1. **모든 순열을 탐색**
   - N ≤ 8 이므로 가능한 순열의 수는 최대 8! = 40,320 → 완전탐색 가능.
2. **DFS + 백트래킹으로 순열 생성**
   - `visited[]` 배열로 사용 여부를 체크하며 깊이 우선 탐색.

---

## 핵심 아이디어

- **순열 생성**: 깊이 `depth`가 N이 되면 한 순열이 완성.
- 완성된 순열 `perm[]`에 대해 인접한 원소 차이의 절댓값 합을 계산.
- 최대 합을 전역 변수 `max`로 관리.

---

## 주요 메서드 및 자료구조

- **자료구조**
  - `int[] A` : 입력 배열
  - `int[] perm` : 현재 생성 중인 순열 저장
  - `boolean[] visited` : 각 인덱스 사용 여부
  - `int[]` 배열과 `boolean[]` 배열만 사용하여 메모리 부담이 적다.
- **핵심 메서드**
  - `dfs(int depth)` : 순열을 백트래킹으로 생성하고 합을 계산.
  - **dfs(depth)** : 깊이 우선 탐색으로 순열을 생성.
  - `visited` : 숫자 사용 여부 관리.
  - `perm` : 현재 구성 중인 순열 저장.

---

## 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon10819 {

    // 전역 변수 선언
    static int N;              // 배열 A의 크기
    static int[] A;           // 입력받은 정수 배열
    static boolean[] visited; // 해당 인덱스를 이미 사용했는지 체크
    static int[] perm;        // 현재 생성 중인 순열 배열
    static int max = 0;       // 식의 최댓값 저장

    public static void main(String[] args)throws IOException {
        // 입력을 빠르게 받기 위한 BufferedReader 사용
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 첫 줄: 배열의 길이 입력
        N = Integer.parseInt(br.readLine());

        // 배열과 기타 변수 초기화
        A = new int[N];
        perm = new int[N];
        visited = new boolean[N];

        // 둘째 줄: 배열 A 입력
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            A[i] = Integer.parseInt(st.nextToken());
        }

        // 순열 생성 및 계산 시작
        dfs(0);

        // 결과 출력
        System.out.println(max);
    }

    // 깊이 우선 탐색 (DFS) 기반 순열 생성 함수
    static void dfs(int depth){
        // 순열 완성 (N개의 숫자를 모두 선택했을 때)
        if(depth == N){
            int sum = 0;
            // 완성된 perm 배열로 문제에서 주어진 식 계산
            for (int i = 0; i < N-1; i++) {
                sum += Math.abs(perm[i] - perm[i+1]);
            }
            // 현재 순열의 결과가 최댓값보다 크면 갱신
            max = Math.max(sum, max);
            return;
        }

        // 아직 선택하지 않은 숫자를 선택
        for (int i = 0; i < N; i++) {
            if(!visited[i]){ // 아직 A[i]를 사용하지 않았다면
                visited[i] = true;       // 사용 처리
                perm[depth] = A[i];      // 현재 순열의 해당 위치에 값 할당
                dfs(depth+1);            // 다음 깊이로 재귀 호출
                visited[i] = false;      // 백트래킹: 사용 해제 (다른 경우의 수 탐색)
            }
        }
    }
}

```

---

## 시간 복잡도

- 순열 생성: O(N!)
- 각 순열에서 합 계산: O(N)
- 전체: O(N × N!)
- N ≤ 8이므로 약 8 × 40,320 ≈ 322,560 연산 → 충분히 가능.

---

## 💡 마무리

이 문제는 **완전 탐색(Brute Force)**과 **백트래킹(Backtracking)**의 장점을 다시금 확인할 수 있었다.<br>
순열을 직접 생성해 모든 경우를 탐색해야 하기에 최적화 여지가 거의 없지만, 입력 크기가 작아 충분히 가능하다.<br>
구현 과정에서 재귀 호출과 `visited` 배열을 적절히 관리하는 것이 핵심이었고, 특히 백트래킹을 통해 불필요한 경로를 빠르게 되돌아가며 효율적으로 순열을 탐색할 수 있었다.

---

## 느낀점

순열을 모두 탐색하는 전형적인 백트래킹 문제다.
처음엔 브루트포스로 비효율적일 것 같았지만, 입력 크기가 작아 완전탐색이 오히려 간단하고 안전한 접근임을 다시 확인했다.
visited 배열로 상태를 관리하고 재귀 종료 시 원상복구(백트래킹)하는 로직이 DFS 기본 패턴임을 복습할 수 있었다.
단순한 완전탐색 문제라 하더라도, 코드 구조와 변수 관리가 깔끔해야 디버깅이 쉽다는 점을 다시 체감했다.
