---
title: "[백준 1941번] 소문난 칠공주 👑"
date: 2025-11-07
categories: [Baekjoon, DFS, 완전탐색]
tags: [백준, DFS, 완전탐색, 브루트포스, 조합, BFS]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# ✅ 백준 1941번 --- 소문난 칠공주 👑

7명의 학생을 뽑는데 **S파가 4명 이상**, 그리고 **7명이 모두 상하좌우로
연결되어 있어야 한다**는 조건 아래 가능한 조합의 수를 찾는 문제입니다.

아래는 내가 직접 제출한 Java 코드이며, 전체적인 알고리즘 접근 방식과
시간 복잡도 분석 등을 담았습니다.

---

# 📌 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class baekjoon1941 {
    // 5x5 보드에 S(이다솜파), Y(임도연파)를 저장
    static char[][] board = new char[5][5];
    // 정답 (가능한 칠공주 조합의 수)
    static int answer = 0;
    // 상하좌우 이동 방향
    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};


    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 5줄 입력받아 5x5 보드에 저장
        for (int i = 0; i < 5; i++) {
            String input = br.readLine();
            for (int j = 0; j < 5; j++) {
                board[i][j] = input.charAt(j);
            }
        }

        // 25개의 좌석 중 7개를 선택하기 위한 boolean 배열
        boolean[] selected = new boolean[25];

        // 0번째 인덱스부터 25개 중 7개를 고르는 DFS 시작
        dfs(0, 0, selected);

        // 가능한 모든 칠공주의 경우의 수 출력
        System.out.println(answer);
    }

    /**
     * dfs(idx, depth, selected)
     * → 25칸 중 7칸을 선택하는 조합을 만드는 함수
     *
     * @param idx      현재 탐색 중인 인덱스 (0~24)
     * @param depth    지금까지 선택한 칸의 개수
     * @param selected 어떤 칸이 선택되었는지를 저장하는 배열
     */
    static void dfs(int idx, int depth, boolean[] selected){
        // 7개를 다 골랐다면 조건 검사
        if(depth == 7){
            if(isValid(selected)) answer++; // 조건을 만족하면 경우의 수 증가
            return;
        }

        // 25칸을 다 봤는데 7개를 못 골랐다면 종료
        if(idx >= 25) return;

        // 현재 idx 칸을 선택하는 경우
        selected[idx] = true;
        dfs(idx + 1, depth + 1, selected);

        // 현재 idx 칸을 선택하지 않는 경우
        selected[idx] = false;
        dfs(idx + 1, depth, selected);
    }

    /**
     * isValid(selected)
     * → 현재 선택된 7칸이 '이다솜파 4명 이상' & '모두 연결되어 있는지'를 확인
     */
    static boolean isValid(boolean[] selected){
        List<int[]> positions = new ArrayList<>(); // 선택된 칸의 좌표 저장
        int sCnt = 0; // S의 개수 (이다솜파 수)

        // 선택된 칸들 좌표 추출 및 S 개수 세기
        for (int i = 0; i < 25; i++) {
            if(selected[i]){
                int x = i / 5; // 행
                int y = i % 5; // 열
                positions.add(new int[]{x, y});
                if(board[x][y] == 'S') sCnt++; // 이다솜파 학생이면 카운트 증가
            }
        }

        // 이다솜파가 4명 미만이면 조건 불충족
        if(sCnt < 4) return false;

        // 선택된 7칸이 서로 연결되어 있는지 BFS로 검사
        Queue<int[]> q = new LinkedList<>();
        boolean[][] visited = new boolean[5][5];

        // 첫 번째 선택된 칸부터 탐색 시작
        q.add(positions.get(0));
        visited[positions.get(0)[0]][positions.get(0)[1]] = true;
        int connected = 1; // 연결된 칸 수

        // BFS 탐색 시작
        while(!q.isEmpty()){
            int[] cur = q.poll(); // 현재 좌표 꺼내기

            // 상하좌우 4방향 검사
            for (int i = 0; i < 4; i++) {
                int nx = cur[0] + dx[i];
                int ny = cur[1] + dy[i];

                // 1) 범위 벗어나면 무시
                if(nx < 0 || ny < 0 || nx >= 5 || ny >= 5) continue;

                // 2) 이미 방문한 곳이면 무시
                if(visited[nx][ny]) continue;

                // 3) 선택되지 않은 칸이면 무시
                if(!selected[nx * 5 + ny]) continue;

                // 위 조건을 통과했다면 같은 그룹에 속하는 인접 칸
                visited[nx][ny] = true;
                connected++;
                q.add(new int[]{nx, ny});
            }
        }

        // BFS 결과로 7칸이 모두 연결돼 있으면 true 반환
        return connected == 7;
    }
}

```

---

# 🧠 핵심 아이디어 정리

## ✅ 1. **25칸 중 7칸 고르는 조합 → DFS로 해결**

- 단순하게 25C7 = 480,700가지\
- 완전탐색 가능

→ `dfs(idx, depth)` 형태로 모든 경우를 탐색

---

## ✅ 2. **조건 1 --- S가 최소 4명 이상**

미리 7개 좌표를 뽑은 후 `S`의 개수를 확인\
→ 단 4명 미만이면 바로 false

---

## ✅ 3. **조건 2 --- 7명이 서로 연결되어 있는지 BFS로 검사**

선택한 7칸을 기준으로 BFS로 개수를 세며\
연결된 칸 수가 `7이면 true`

---

# 🧾 주요 메서드 설명

### ✅ `dfs(int idx, int depth)`

- 0\~24 사이에서 7개 선택
- 선택/비선택 2가지 분기
- depth==7이면 조건 검사

### ✅ `isValid(boolean[] selected)`

- 선택된 좌표 리스트 만들기
- S 카운트
- BFS로 연결 여부 체크

---

# ⏱️ 시간 복잡도 분석

### ✅ 조합 탐색

- 최대 25C7 ≈ **48만**

### ✅ 각 조합마다 BFS

- BFS 크기: 최대 노드 7개 → O(7)

✅ **총 시간: 약 48만 × 7 = 336만 연산 수준 → 충분히 빠름**

---

# ✨ 사용한 자료구조

자료구조 용도

---

`boolean[] selected` 25칸 중 선택 여부
`List<int[]>` 선택된 좌표 저장
`Queue<int[]>` BFS 탐색용
`boolean[][] visited` BFS 방문 체크

---

# 💡 이번 문제를 해결하며 느낀 점

이 문제는 단순히 "조합을 뽑는 완전탐색"이 아니라,\
뽑힌 조합에 대해 **유효성 검사(BFS)**를 결합해야 해서 구현력이 요구되는
문제였다.

특히 다음이 핵심 포인트였다:

- 25칸 중 7칸 선택은 DFS 조합으로 해결\
- 조건 검사는 BFS로 분리하여 깔끔하게 처리\
- S가 4명 이상이어야 하기 때문에 조합을 뽑고 난 후 필터링

구현 난이도는 높은 편이지만,\
**완전탐색 + 그래프 탐색의 조합을 어떻게 정교하게 적용하는지** 배울 수
있는 좋은 문제라고 느꼈다.

---

# ✅ 마무리

이 문제는 완전탐색, 조합, DFS, BFS, 그래프 연결성 등\
여러 가지 개념을 한 번에 다뤄서 실력 향상에 매우 도움이 된다.

---
