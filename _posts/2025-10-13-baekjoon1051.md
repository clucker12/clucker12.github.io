---
title: "[백준 1051] 숫자 정사각형 풀이 - Java"
date: 2025-10-13
categories: [Baekjoon, Java]
tags: [Java, 완전탐색, BruteForce, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 🧮 백준 1051번 - 숫자 정사각형

---

## 📘 문제 설명

N×M 크기의 직사각형이 주어진다.  
이 중 네 꼭짓점의 숫자가 모두 같은 정사각형 중, 가장 큰 정사각형의 넓이를 구하는 문제이다.

---

## 💻 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon1051 {
    // N: 행 개수, M: 열 개수
    static int N, M;

    // 2차원 배열: 숫자들이 들어있는 직사각형
    static int[][] board;

    public static void main(String[] args) throws IOException {
        // 빠른 입력을 위한 BufferedReader 사용
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 첫 줄 입력 (N, M)
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken()); // 행
        M = Integer.parseInt(st.nextToken()); // 열

        // 배열 초기화
        board = new int[N][M];

        // 숫자판 입력 받기 (줄마다 한 줄씩, 각 글자를 숫자로 변환)
        for (int i = 0; i < N; i++) {
            String line = br.readLine(); // 예: "42101"
            for (int j = 0; j < M; j++) {
                // 문자를 숫자로 변환해서 배열에 저장
                board[i][j] = line.charAt(j) - '0';
            }
        }

        // 현재까지 찾은 가장 큰 정사각형의 한 변 길이 (초기값 1)
        int maxLen = 1;

        // 모든 좌표 (i,j) 에서 시작 가능한 정사각형을 탐색
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {

                // 정사각형의 크기를 하나씩 늘려가며 확인
                for (int size = 1; i + size < N && j + size < M; size++) {
                    int val = board[i][j]; // 기준 꼭짓점의 숫자

                    // 정사각형의 4 꼭짓점이 같은 숫자인지 확인
                    if (board[i][j + size] == val &&        // 우측 상단
                            board[i + size][j] == val &&        // 좌측 하단
                            board[i + size][j + size] == val) { // 우측 하단

                        // 4 꼭짓점이 모두 같다면, 최대 길이 갱신
                        maxLen = Math.max(maxLen, size + 1);
                    }
                }
            }
        }

        // 정사각형의 넓이 = 한 변의 길이 제곱
        System.out.println(maxLen * maxLen);
    }
}

```

---

## 💡 접근 방법

1. 모든 좌표 `(i, j)`를 시작점으로 정한다.
2. 정사각형의 크기를 `1`씩 늘려가며 가능한 모든 크기를 탐색한다.
3. 네 꼭짓점이 같은 숫자인 경우, 최대 변의 길이를 갱신한다.
4. 마지막에 `(최대 변)^2`을 출력한다.

---

## 🧩 핵심 로직 요약

- 완전탐색(Brute Force) 기반 접근
- 네 꼭짓점만 확인하면 되므로 효율적이다.
- 반복문 세 개를 사용하여 모든 가능한 정사각형을 검사한다.

---

## 🧱 사용된 자료구조

| 자료형          | 역할                                  |
| --------------- | ------------------------------------- |
| `int[][] board` | 입력받은 숫자판 저장                  |
| `int maxLen`    | 찾은 정사각형 중 가장 긴 한 변의 길이 |

---

## ⏱️ 시간 복잡도

모든 좌표 `(i, j)`에서 가능한 정사각형 크기를 탐색하므로  
**O(N × M × min(N, M))**  
(N, M ≤ 50이므로 충분히 가능)

---

## 🔍 주요 메서드 및 로직

| 구문                                    | 설명                               |
| --------------------------------------- | ---------------------------------- |
| `for (size = 1; ...)`                   | 정사각형 크기를 점차 늘려가며 탐색 |
| `if (board[i][j + size] == val && ...)` | 네 꼭짓점 숫자 일치 여부 확인      |
| `Math.max(maxLen, size + 1)`            | 최대 변 길이 갱신                  |
| `System.out.println(maxLen * maxLen)`   | 최종 넓이 출력                     |

---

## 💬 느낀점

이 문제는 **단순한 완전탐색 문제지만, 구현 아이디어가 직관적인 문제**였다.  
모든 칸에서 정사각형을 검사하는 과정에서 **조건 단순화(4개 꼭짓점만 비교)**가 포인트였다.

처음엔 모든 칸을 전부 탐색하므로 복잡할 것 같았지만,  
사실상 꼭짓점만 확인하면 되기 때문에 효율적으로 해결 가능했다.

이 문제를 통해 **브루트포스 접근 시 불필요한 연산을 줄이는 방법**을 다시 생각해볼 수 있었다.  
단순하지만 논리적인 문제 접근 훈련에 도움이 되었다. 🚀
