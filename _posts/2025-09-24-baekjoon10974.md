---
title: "[백준 10974] 모든 순열 문제 풀이 - Java"
date: 2025-09-24
categories: [Baekjoon, Java]
tags: [백트래킹, DFS, 순열, 구현, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 📝 문제 개요

**문제 번호:** 10974  
**문제 이름:** 모든 순열  
**난이도:** 실버3

1부터 N까지의 수로 만들 수 있는 **모든 순열**을 한 줄에 하나씩 출력하는 문제입니다.

---

## 💡 접근 방법

- **백트래킹(Backtracking)**과 **DFS**를 이용해 1부터 N까지의 모든 수를 한 번씩 사용하여 순열을 생성합니다.
- 재귀 함수 `dfs`를 통해 깊이 우선 탐색으로 모든 경우를 탐색하고, `visited` 배열을 사용하여 이미 선택된 숫자는 제외합니다.

---

## 📜 핵심 아이디어

- **순열 생성**: 깊이가 N이 되면 하나의 완성된 순열을 출력합니다.
- **백트래킹**: 탐색이 끝나면 방문 여부를 해제(`visited[i] = false`)해 다른 조합을 탐색할 수 있도록 합니다.

---

## 💻 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class baekjoon10974 {
    // 전역 변수 선언
    static int N;              // 숫자의 개수 (1부터 N까지)
    static int[] perm;         // 순열을 저장할 배열
    static boolean[] visited;  // 숫자 사용 여부를 체크하는 배열

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // N 입력 받기
        N = Integer.parseInt(br.readLine());

        // 배열 초기화
        perm = new int[N];         // 순열 배열 (길이 N)
        visited = new boolean[N];  // 숫자 사용 여부 체크 (0~N-1까지)

        // 순열 생성 시작 (깊이 0부터 시작)
        dfs(0);
    }

    // 깊이 우선 탐색 (백트래킹)으로 순열 생성
    static void dfs(int depth) {
        // 종료 조건: 순열이 완성되었을 경우 (depth == N)
        if (depth == N) {
            for (int i = 0; i < N; i++) {
                System.out.print(perm[i] + " ");
            }
            System.out.println();  // 한 줄 출력 후 줄 바꿈
            return;
        }

        // 1부터 N까지 숫자 중 하나 선택 (i는 0부터 N-1까지)
        for (int i = 0; i < N; i++) {
            if (!visited[i]) {              // 아직 사용하지 않은 숫자라면
                visited[i] = true;          // 해당 숫자 사용 처리
                perm[depth] = i + 1;        // 순열 배열에 숫자 저장 (i+1이 실제 숫자)
                dfs(depth + 1);             // 다음 깊이로 재귀 호출
                visited[i] = false;         // 백트래킹: 숫자 사용 해제
            }
        }
    }
}

```

---

## ⏱️ 시간 복잡도

- **순열의 개수:** N! (팩토리얼)
- 각 순열을 출력하는 데 O(N) 시간이 필요하므로 **총 시간 복잡도는 O(N × N!)** 입니다.

---

## 🔑 주요 메서드 및 로직 설명

- **dfs(int depth)**
  - `depth`: 현재 깊이(선택한 숫자의 개수)
  - 종료 조건: depth == N → 현재까지 선택한 순열 출력
  - 백트래킹: 방문한 숫자를 해제하여 다음 조합 탐색
- **자료구조**
  - `perm[]`: 현재 순열을 저장
  - `visited[]`: 숫자의 사용 여부를 체크

---

## 🧐 중요한 포인트

- `visited` 배열을 통해 각 숫자가 한 번씩만 선택되도록 제어합니다.
- 백트래킹으로 모든 경우의 수를 탐색하며, 재귀가 끝날 때 상태를 원복해 다른 조합을 만들 수 있게 합니다.

---

## ✨ 마무리 & 느낀점

단순히 순열을 출력하는 문제이지만, **백트래킹의 기초**를 익히기에 매우 좋은 문제입니다.  
특히, 재귀 호출과 상태 복원의 개념을 명확히 이해하는 것이 중요했습니다.  
이번 문제를 통해 순열 문제에서의 DFS와 백트래킹을 보다 깊이 있게 이해할 수 있었으며, 더 큰 N에서도 효율적인 탐색을 위해 어떻게 상태를 관리해야 하는지 깨닫게 되었습니다.
