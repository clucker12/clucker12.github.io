---
title: "[백준 18111] 마인크래프트 문제 풀이 - Java"
date: 2025-09-25
categories: [Baekjoon, Java]
tags: [구현, 브루트포스, 시뮬레이션, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 문제 설명

N×M 크기의 땅이 주어졌을 때, 블록을 제거하거나 추가하여 모든 칸의 높이를
동일하게 맞추는 데 필요한 최소 시간을 구하는 문제입니다.\

- **제거**: 블록 하나당 2초 - **추가**: 블록 하나당 1초\
  단, 인벤토리에 있는 블록 수를 초과해서는 안 됩니다.

---

## 접근 방법

1.  **전체 높이 범위 탐색**
    - 땅의 최소 높이(min)부터 최대 높이(max)까지 가능한 모든 목표 높이
      h에 대해 브루트포스로 탐색.
2.  **시뮬레이션**
    - 각 높이에 대해 필요한 블록 제거/추가 수를 계산.
    - 제거한 블록은 인벤토리에 더해져 추가에 사용할 수 있음.
3.  **시간 계산 및 갱신**
    - 제거: 2초, 추가: 1초를 합산해 현재 높이의 소요 시간을 구함.
    - 최소 시간 갱신 및 같은 시간이라면 더 높은 높이를 우선 선택.

---

## 핵심 로직

- 모든 좌표를 순회하며 목표 높이와의 차이를 계산해 제거 및 추가 블록
  수를 합산합니다.
- 인벤토리 블록 + 제거 블록이 추가 블록 이상이어야 목표 높이가
  가능합니다.
- `currentTime = remove * 2 + add` 를 이용해 총 시간을 계산합니다.

---

## 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon18111 {

    // 전역 변수 선언
    static int N, M, B;               // N: 세로, M: 가로, B: 인벤토리 블록 수
    static int[][] groud;            // 땅 높이를 저장할 2차원 배열
    static int maxHeight = 0;        // 결과로 나올 가장 높은 땅 높이
    static int minTime = Integer.MAX_VALUE;  // 최소 작업 시간 (초기값: 아주 큰 수)

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 첫 줄 입력: N, M, B
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken()); // 세로 크기
        M = Integer.parseInt(st.nextToken()); // 가로 크기
        B = Integer.parseInt(st.nextToken()); // 인벤토리 블록 수

        groud = new int[N][M]; // 땅 배열 초기화
        int min = 256;         // 땅 높이의 최소값 (최소 높이 기준)
        int max = 0;           // 땅 높이의 최대값 (최대 높이 기준)

        // 땅의 높이 입력 받기
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < M; j++) {
                groud[i][j] = Integer.parseInt(st.nextToken()); // (i,j) 위치의 땅 높이
                min = Math.min(min, groud[i][j]); // 최소 높이 갱신
                max = Math.max(max, groud[i][j]); // 최대 높이 갱신
            }
        }

        // 가능한 높이(min~max)마다 시도
        for (int h = min; h <= max; h++) {
            int remove = 0; // 제거할 블록 수
            int add = 0;    // 추가할 블록 수

            // 모든 좌표에 대해 블록을 제거/추가하는 데 필요한 수 계산
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < M; j++) {
                    int height = groud[i][j]; // 현재 좌표의 높이

                    if (height > h) {
                        // 현재 높이가 목표보다 높으면 제거
                        remove += height - h;
                    } else {
                        // 현재 높이가 목표보다 낮으면 추가
                        add += h - height;
                    }
                }
            }

            // 인벤토리에 있는 블록 + 제거한 블록 >= 추가할 블록이어야 가능
            if (remove + B >= add) {
                int currentTime = remove * 2 + add; // 제거는 2초, 추가는 1초

                // 최소 시간일 경우 또는 같은 시간이지만 더 높은 높이를 만들 수 있으면 갱신
                if (currentTime < minTime || (currentTime == minTime && h > maxHeight)) {
                    minTime = currentTime;
                    maxHeight = h;
                }
            }
        }

        // 결과 출력: 최소 시간, 해당하는 최대 높이
        System.out.println(minTime + " " + maxHeight);
    }
}

```

---

## 자료구조 & 메서드 설명

- **2차원 배열 `groud`** : 각 위치의 땅 높이를 저장.
- **이중 for문** : 모든 좌표를 탐색해 제거 및 추가 블록 수 계산.
- **BufferedReader & StringTokenizer** : 빠른 입력 처리를 위해 사용.

---

## 시간 복잡도

- 가능한 높이 범위: `max - min + 1`
- 각 높이마다 N×M 칸을 모두 탐색하므로 **O((max-min) × N × M)**
- N, M ≤ 500, 높이 범위 ≤ 256이므로 충분히 계산 가능.

---

## 💡 마무리 & 느낀점

이 문제는 단순한 구현 문제 같지만, 완전 탐색과 시뮬레이션의 결합으로 접근해야 했습니다.
최적화보다는 정확한 로직이 중요했으며, 제거와 추가 시간을 다르게 적용하는 점, 인벤토리 블록 조건을 꼼꼼히 체크하는 점이 핵심 포인트였습니다.

브루트포스로도 충분히 풀 수 있는 이유는 높이 범위가 제한적이기 때문입니다. 이 과정을 통해 **제약 조건 분석**과 **완전 탐색의 한계**를 고려하는 훈련이 되었습니다.
