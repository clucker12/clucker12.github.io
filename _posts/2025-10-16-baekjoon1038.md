---
title: "[백준 1038] 감소하는 수 (DFS & 백트래킹) - Java"
date: 2025-10-16
categories: [Baekjoon, Java]
tags: [DFS, 백트래킹, 브루트포스, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 🧩 문제 개요

> **문제 번호:** [백준 1038 - 감소하는 수](https://www.acmicpc.net/problem/1038)  
> **난이도:** 골드 5  
> **알고리즘 분류:** DFS / 백트래킹 / 브루트포스

---

# 🧠 문제 설명

감소하는 수란 **각 자리의 숫자가 앞자리보다 항상 작은 수**를 말합니다.  
예를 들어,

- `321`, `750`, `10`, `0` 은 감소하는 수이지만
- `122`, `99`, `5435` 는 감소하는 수가 아닙니다.

이 문제는 **N번째 감소하는 수**를 구하는 문제입니다.  
감소하는 수는 총 1023개(0부터 9876543210까지)밖에 존재하지 않으므로, 완전 탐색으로도 충분히 해결할 수 있습니다.

---

# 💻 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class baekjoon1038 {
    static int N; // 입력으로 주어지는 N번째 감소하는 수
    static List<Long> list = new ArrayList<>(); // 감소하는 수를 저장할 리스트

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine()); // N 입력 받기

        // 0부터 9까지 한 자리 수를 시작으로 DFS 호출
        for (int i = 0; i <= 9; i++) {
            dfs(i, 1); // 현재 숫자 i를 시작으로 DFS 탐색 시작
        }

        // 감소하는 수를 모두 수집한 후 오름차순 정렬
        Collections.sort(list);

        // N번째 감소하는 수가 존재하지 않으면 -1 출력
        if (N >= list.size()) {
            System.out.println(-1);
        } else {
            // 존재한다면 N번째 감소하는 수 출력
            System.out.println(list.get(N));
        }
    }

    /**
     * 감소하는 수를 재귀적으로 생성하는 DFS 함수
     * @param current 현재까지 만들어진 숫자
     * @param length  현재 자릿수 (사용되지는 않지만 일반적으로 깊이 정보로 포함 가능)
     */
    static void dfs(long current, int length) {
        // 현재 숫자를 리스트에 추가
        list.add(current);

        // current의 마지막 자리 숫자보다 작은 숫자만 다음 자리에 붙일 수 있음
        // (엄격한 감소 조건이므로 같은 숫자나 큰 숫자는 안 됨)
        for (int i = 0; i < current % 10; i++) {
            // 다음 자리 숫자를 붙이고 재귀 호출
            // 예: current = 3 → 32, 31, 30 시도 (i = 2, 1, 0)
            dfs(current * 10 + i, length + 1);
        }
    }
}

```

---

# ⚙️ 주요 로직 및 핵심 개념

### 🔹 1. 감소하는 수의 특징

- 각 자리의 숫자가 이전 자리보다 작아야 함.
- 즉, 가장 큰 감소하는 수는 `9876543210` (길이 10).

### 🔹 2. DFS 탐색 방식

- 0~9로 시작하여 다음 자리수는 항상 **더 작은 숫자만 붙이는** 방식으로 모든 감소하는 수 생성.
- 예: `5 → 54, 53, 52, 51, 50`

### 🔹 3. 자료구조

- `ArrayList<Long>` : 생성된 모든 감소하는 수를 저장.
- 이후 `Collections.sort()`로 정렬하여 오름차순 인덱스로 접근.

### 🔹 4. 종료 조건

- 감소하는 수는 총 1023개로 제한되어 있으므로, 모든 경우를 DFS로 생성해도 시간 초과 없음.

---

# ⏱ 시간 복잡도

- DFS를 통해 생성되는 모든 감소하는 수의 개수는 **1023개 (2¹⁰ - 1)**
- 각 수는 최대 10자리이므로 연산량은 매우 작음.  
  👉 **O(1023 × 10) ≈ O(1)** (상수 시간에 가까움)

---

# 💡 마무리

이 문제는 **완전 탐색(브루트포스)** 과 **DFS** 의 개념을 동시에 복습할 수 있는 좋은 문제입니다.  
감소하는 수의 개수가 유한하다는 점을 이용해 탐색 공간을 제한하고, 재귀적으로 모든 경우를 만들어 해결했습니다.

---

# 🧭 느낀점 & 접근 방법

처음엔 단순히 반복문으로 만들 수 있을까 고민했지만,  
자리 수가 달라질수록 **이전 숫자보다 작아야 한다는 제약** 때문에 규칙성이 명확하지 않았습니다.

그래서 **재귀적으로 마지막 자리보다 작은 수만 붙이는 DFS 방식**을 사용했고,  
모든 감소하는 수를 한 번씩 생성한 후 정렬하면 손쉽게 N번째 수를 찾을 수 있었습니다.

이 문제를 통해 **브루트포스 탐색의 효율적인 설계**와 **DFS로 조합을 생성하는 패턴**을 다시 한번 익혔습니다. 🚀

---
