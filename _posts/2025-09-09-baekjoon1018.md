---
title: "[백준 1018] - 체스판 다시 칠하기 - Java 풀이"
date: 2025-09-09
categories: [Baekjoon, Java]
tags: [브루트포스, 구현, 체스판, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 📝 문제 설명

백준 1018번 **체스판 다시 칠하기** 문제는 주어진 N×M 보드에서 8×8 크기의 체스판을 골라, 체스판 규칙(흑백이 번갈아 배치)에 맞게 다시 칠해야 하는 최소 칸 수를 구하는 문제입니다.

즉, 모든 가능한 8×8 영역을 탐색하고, "흰색 시작" / "검은색 시작" 두 경우 중 최소 칠해야 하는 칸 수를 찾아야 합니다.

---

# 📌 접근 방법

1. **브루트포스(Brute Force)**

   - 가능한 모든 8×8 체스판의 시작점을 확인해야 하므로, `(N-7) × (M-7)` 개의 시작점이 생깁니다.
   - 각 시작점에서 8×8 영역을 검사하며, "시작 색이 W"인 경우와 "시작 색이 B"인 경우를 모두 계산합니다.
   - 두 경우 중 더 적은 칸을 칠하는 값이 해당 구간의 최소값이 됩니다.

2. **조건 확인**

   - `(i + j) % 2 == 0` → 시작 칸과 같은 색이어야 함
   - `(i + j) % 2 == 1` → 시작 칸과 반대 색이어야 함

3. **최소값 갱신**
   - 전체 보드를 탐색하면서 가장 적게 칠하는 경우를 찾습니다.

---

# 💻 코드 (Java)

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon1018 {
    static int N, M;               // 보드의 크기 N행 M열
    static char[][] board;         // 보드 상태를 저장하는 2차원 배열
    static int min = Integer.MAX_VALUE; // 최소 다시 칠해야 할 칸 수 (초기값은 매우 큰 수)

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 첫 번째 줄에서 N과 M 읽기
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        // 보드 배열 초기화
        board = new char[N][M];

        // 보드 상태 입력 받기
        for (int i = 0; i < N; i++) {
            String line = br.readLine();
            for (int j = 0; j < M; j++) {
                // 각 칸의 색깔('B' 또는 'W')를 char로 저장
                board[i][j] = line.charAt(j);
            }
        }

        // 8x8 체스판을 만들 수 있는 모든 시작 위치에 대해서 검사
        // i, j가 시작 좌표로, 8x8 범위를 벗어나지 않도록 <= N-8, M-8 까지 반복
        for (int i = 0; i <= N - 8; i++) {
            for (int j = 0; j <= M - 8; j++) {
                check(i, j); // (i,j)부터 8x8 부분을 검사하는 함수 호출
            }
        }

        // 최종적으로 최소 칠해야 할 개수를 출력
        System.out.println(min);
    }

    // (startX, startY)부터 시작하는 8x8 영역에서 다시 칠해야 하는 최소 칸 수를 계산하는 함수
    static void check(int startX, int startY) {
        int countStartW = 0; // 체스판 시작 칸이 'W'일 때 다시 칠해야 하는 칸 수
        int countStartB = 0; // 체스판 시작 칸이 'B'일 때 다시 칠해야 하는 칸 수

        // 8x8 범위 내에서 모든 칸을 순회
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                // 실제 보드의 좌표 계산
                int x = startX + i;
                int y = startY + j;
                char current = board[x][y]; // 현재 칸 색상

                // (i + j) % 2 == 0 인 칸은 체스판 시작 칸과 같은 색이어야 함
                if ((i + j) % 2 == 0) {
                    // 시작 칸이 'W'인 체스판으로 볼 때,
                    // 현재 칸이 'W'가 아니면 다시 칠해야 함
                    if (current != 'W') countStartW++;

                    // 시작 칸이 'B'인 체스판으로 볼 때,
                    // 현재 칸이 'B'가 아니면 다시 칠해야 함
                    if (current != 'B') countStartB++;

                    // (i + j) % 2 == 1 인 칸은 체스판 시작 칸과 반대 색이어야 함
                } else {
                    // 시작 칸이 'W'인 경우, 이 칸은 'B'여야 하므로
                    // 현재 칸이 'B'가 아니면 다시 칠해야 함
                    if (current != 'B') countStartW++;

                    // 시작 칸이 'B'인 경우, 이 칸은 'W'여야 하므로
                    // 현재 칸이 'W'가 아니면 다시 칠해야 함
                    if (current != 'W') countStartB++;
                }
            }
        }

        // 시작 칸이 'W'인 경우와 'B'인 경우 중 더 적은 칸을 다시 칠해야 하므로 최소값 계산
        int localMin = Math.min(countStartW, countStartB);

        // 전체 보드에서 최소 칠해야 할 개수와 비교하여 더 작은 값으로 갱신
        min = Math.min(min, localMin);
    }
}

```

---

# 📊 시간 복잡도

- **가능한 시작 위치 개수**: `(N - 7) × (M - 7)`
- **각 시작 위치마다 검사할 칸 수**: `64` (8×8)
- **총 시간 복잡도**: `O((N-7) × (M-7) × 64)` → `O(N × M)`

N, M ≤ 50이므로 충분히 빠르게 동작합니다.

---

# 🔑 주요 메서드 & 핵심 로직

- `check(startX, startY)`  
  → 8×8 체스판의 다시 칠해야 할 칸 수를 계산.  
  "흰색 시작"과 "검은색 시작" 두 경우를 비교해서 최소값 반환.

- **자료구조**:
  - `char[][] board`: 보드의 상태를 저장하는 2차원 배열.
  - 단순 배열과 반복문만 사용하여 풀이.

---

# 💡 마무리

이 문제는 **브루트포스의 정석** 같은 문제였습니다.

- 처음엔 단순히 8×8씩 잘라서 검사하는 방식이 비효율적일 것 같다고 생각했지만,  
  실제로는 입력 크기가 작아 완전 탐색이 가능한 전형적인 구현 문제였습니다.
- (i + j) % 2 규칙을 활용해 칸의 색을 판별하는 아이디어가 핵심이었습니다.

---

# ✨ 느낀점

체스판 문제를 풀면서 **브루트포스와 구현의 기본기를 다지는 연습**이 되었습니다.  
처음에는 "8×8 보드를 일일이 다 검사해야 하나?"라는 생각이 들었지만, 입력 크기가 작아 충분히 가능한 접근이었습니다.

즉, **문제를 풀기 전에 입력 크기를 보고 "완전 탐색이 가능한지"를 먼저 판단하는 습관**을 길러야겠다고 느꼈습니다.

그리고 시작칸 설정과 (i + j) % 2 == 0 인 칸은 체스판 시작 칸과 같은 색, (i + j) % 2 == 1 인 칸은 체스판 시작 칸과 반대 색 설정하는게 어려워서 충분히 더 공부해야겠다고 느꼈습니다.
