---
title: "[백준 2468] - 안전 영역 문제 풀이 - Java 풀이"
date: 2025-09-04
categories: [Baekjoon, Java]
tags: [브루트포스, DFS, BFS, 그래프 탐색, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 📝 문제 설명

백준 2468번 **안전 영역** 문제는 특정 비의 양이 내렸을 때 잠기지 않는 영역(안전 영역)의 개수를 찾는 문제입니다.  
비의 양을 변화시키면서 안전 영역의 최대 개수를 출력해야 합니다.

---

## 📌 접근 방법

1. **최대 높이(maxHeight)까지 모든 비의 양(rain level)을 시뮬레이션**  
   → 각 강수량마다 잠기지 않는 영역을 탐색합니다.
2. **DFS/BFS 탐색으로 연결된 안전 영역을 찾음**  
   → 방문하지 않았고, 현재 강수량보다 높은 지역을 기준으로 탐색.
3. 탐색된 영역 개수를 세고, 그 중 **최댓값을 갱신**합니다.

---

## 🧩 사용 알고리즘

- **브루트포스 (모든 강수량 시뮬레이션)**
- **DFS (깊이 우선 탐색)**
- BFS로도 풀 수 있으나, 이 코드에서는 DFS를 사용했습니다.

---

## 📂 사용 자료구조

- `int[][] s` : 지도 높이 정보 저장
- `boolean[][] visited` : 방문 여부 체크
- `int[] dx, dy` : 상하좌우 방향 벡터

---

## 💻 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon2468 {

    // N: 지도 크기 (N x N), s: 높이 정보 배열
    static int N;
    static int[][] s;

    // 상하좌우 방향 벡터
    static int[] dx = {-1, 1, 0, 0}; // 위, 아래
    static int[] dy = {0, 0, -1, 1}; // 왼쪽, 오른쪽

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // N 입력
        N = Integer.parseInt(br.readLine());
        s = new int[N][N];

        int maxHeight = 0; // 지역 내 최대 높이 저장

        // 높이 정보 입력 받으면서 maxHeight 갱신
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < N; j++) {
                s[i][j] = Integer.parseInt(st.nextToken());
                maxHeight = Math.max(maxHeight, s[i][j]);
            }
        }

        int maxSafeArea = 0; // 최대 안전 영역 개수

        // 비의 양을 0부터 maxHeight-1까지 변화시키며 시뮬레이션
        for (int rain = 0; rain < maxHeight; rain++) {
            boolean[][] visited = new boolean[N][N]; // 방문 여부 배열
            int cnt = 0; // 현재 비의 높이에서의 안전 영역 개수

            // 전체 지역을 탐색
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    // 해당 지점이 비에 잠기지 않았고, 아직 방문하지 않았다면
                    if (!visited[i][j] && s[i][j] > rain) {
                        // DFS 탐색 시작 (연결된 안전 영역 전체 탐색)
                        dfs(i, j, rain, visited);
                        cnt++; // 하나의 안전 영역 발견 → 개수 증가
                    }
                }
            }

            // 지금까지의 최대 안전 영역 개수 갱신
            maxSafeArea = Math.max(maxSafeArea, cnt);
        }

        // 정답 출력
        System.out.println(maxSafeArea);
    }

    // DFS: 상하좌우로 연결된 안전 지역을 탐색하며 visited 표시
    static void dfs(int x, int y, int rain, boolean[][] visited) {
        visited[x][y] = true; // 현재 지점 방문 처리

        // 4방향 모두 탐색
        for (int dir = 0; dir < 4; dir++) {
            int nx = x + dx[dir]; // 다음 위치의 x
            int ny = y + dy[dir]; // 다음 위치의 y

            // 경계 체크
            if (nx >= 0 && ny >= 0 && nx < N && ny < N) {
                // 다음 지점이 비에 잠기지 않고, 아직 방문하지 않았다면
                if (!visited[nx][ny] && s[nx][ny] > rain) {
                    // 재귀적으로 DFS 탐색 계속
                    dfs(nx, ny, rain, visited);
                }
            }
        }
    }
}
```

---

## 📊 시간 복잡도

- O(N² × maxHeight)
  - maxHeight는 최대 100이므로,
  - N ≤ 100일 때 최악의 경우 약 100 × 100² = 1,000,000 → 충분히 가능.

---

## 🔑 주요 메서드 & 핵심 로직

- dfs(x, y, rain, visited)

  - 상하좌우를 탐색하며 연결된 안전 영역을 전부 방문 처리.

- 메인 반복문
  - 강수량을 변화시키며 매번 새로운 visited 배열로 안전 영역 탐색.

---

## 💡 마무리 및 느낀점

이 문제는 브루트포스 + DFS/BFS의 전형적인 조합 문제입니다.<br>
단순히 한 번의 탐색이 아니라, 모든 강수량에 대해 반복해야 한다는 점이 핵심이었습니다.<br>

👉 문제를 풀면서 "조건 변화(강수량)"에 따른 그래프 탐색을 어떻게 반복적으로 적용할지 고민해볼 수 있었습니다.<br>
👉 또한 DFS와 BFS 모두 적용 가능하지만, 재귀 DFS로도 충분히 효율적이라는 점을 확인했습니다<br>
