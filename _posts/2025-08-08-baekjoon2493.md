---
title: "[백준 2493] - 탑 - Java 풀이"
date: 2025-08-08
categories: [Baekjoon, Java]
tags: [스택, 자료구조, 구현, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 📌 문제 설명

백준 2493 **"탑"** 문제는 N개의 탑이 일렬로 세워져 있을 때, 각 탑이 발사한 레이저를 **가장 먼저 수신하는 탑의 번호**를 구하는 문제입니다.  
레이저는 **왼쪽 방향으로만 발사**되며, 자신보다 **높이가 높은 첫 번째 탑**이 수신합니다.

---

## 💡 접근 방법

이 문제를 단순히 이중 반복문으로 풀면 `O(N^2)`가 되어 시간 초과가 발생합니다.  
따라서 **스택(Stack)**을 이용해 **각 탑이 레이저를 발사했을 때 수신할 수 있는 첫 번째 큰 탑**을 효율적으로 찾아야 합니다.

1. **탑의 높이와 인덱스를 스택에 저장**
2. 새로운 탑이 들어올 때, 스택의 top이 현재 탑보다 작으면 pop (작은 탑 제거)
3. 스택에 남아있는 top이 현재 탑의 레이저를 수신 → `result`에 기록
4. 현재 탑을 스택에 push

이 방식은 **각 탑이 스택에 한 번 push되고 최대 한 번 pop**되므로 **O(N)** 시간에 해결할 수 있습니다.

---

## 💻 Java 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class baekjoon2493 {
    public static void main(String[] args) throws IOException {
        // 입력을 위한 BufferedReader 설정
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 탑의 개수 N을 읽어옴
        int N = Integer.parseInt(br.readLine());

        // 결과를 저장할 배열 (각 탑에서 발사된 레이저가 수신되는 탑의 번호를 저장)
        int[] result = new int[N];

        // 각 탑의 높이를 저장할 배열
        int[] height = new int[N];

        // 탑의 인덱스를 저장할 스택 초기화
        Stack<Integer> stack = new Stack<>();

        // 탑의 높이를 입력받아 height 배열에 저장
        String[] input = br.readLine().split(" ");
        for (int i = 0; i < N; i++) {
            height[i] = Integer.parseInt(input[i]);  // 탑의 높이 저장
        }

        // 각 탑에 대해 레이저가 수신되는 탑을 찾는 과정
        for (int i = 0; i < N; i++) {
            // 스택이 비어 있지 않고, 현재 탑의 높이가 스택의 top에 있는 탑의 높이보다 클 때
            // 스택에서 top 값을 계속 pop하여 작은 탑들을 제거
            while (!stack.isEmpty() && height[stack.peek()] < height[i]) {
                stack.pop();  // 현재 탑보다 작은 탑을 제거
            }

            // 만약 스택에 탑이 남아 있으면, 그 탑이 현재 탑에서 발사된 레이저를 수신하는 탑
            if (!stack.isEmpty()) {
                // 수신 탑의 인덱스를 1-based로 기록
                result[i] = stack.peek() + 1;
            }

            // 현재 탑의 인덱스를 스택에 추가 (이 탑은 다른 탑의 레이저를 수신할 수 있을 수 있음)
            stack.push(i);
        }

        // 결과 배열을 StringBuilder에 추가하여 출력
        StringBuilder sb = new StringBuilder();
        for (int res : result) {
            sb.append(res).append(" ");  // 각 결과를 공백으로 구분하여 붙여줌
        }

        // 최종 결과 출력 (마지막 공백 제거)
        System.out.println(sb.toString().trim());
    }
}
```

---

## ⏱ 시간 복잡도

- 각 탑은 최대 한 번 push + 한 번 pop → O(N)
- 전체 입력 처리 및 출력 → O(N)
- 총 시간 복잡도: O(N)
- 공간 복잡도: O(N) (스택과 배열 사용)

---

## 🔍 주요 메서드 & 핵심 로직

- Stack<Integer>
  → 탑의 인덱스를 저장하여 높이 비교 시 height[index]로 접근
- while 루프
  → 현재 탑보다 낮은 탑을 스택에서 제거하여, 항상 큰 탑만 남김
- stack.peek()
  → 현재 탑의 레이저를 수신할 수 있는 가장 가까운 높은 탑의 인덱스를 반환
- StringBuilder
  → 빠른 문자열 연결로 결과 출력 최적화

---

## 🗂 자료구조 설명

- 스택(Stack)
  - LIFO 구조 (마지막에 들어온 것이 먼저 나옴)
  - 이전에 본 탑들의 높이를 저장하며, 현재 탑보다 작은 탑은 pop으로 제거
    → 불필요한 비교를 줄여 시간 효율 극대화

---

## 💡마무리 (느낀점)

이 문제는 **"이전의 정보 중에서 필요한 것만 남기고 불필요한 것은 버린다"**라는 스택의 활용 패턴을 잘 보여줍니다.
처음 접근할 때는 단순 비교로 구현하려 했지만, 시간 복잡도가 O(N^2)라서 실패할 수밖에 없었습니다.

스택을 사용하면 탑의 높이를 한 번씩만 확인하고도 원하는 결과를 얻을 수 있어,
**"불필요한 연산을 어떻게 제거할 것인가?"**라는 관점에서 좋은 훈련이 되었습니다.

---

## 📌 접근 정리

1. 단순 비교 방식은 비효율적 → 시간 초과 위험
2. 스택을 사용하면 한 번의 탐색으로 해결 가능
3. "현재보다 큰 값 중 가장 가까운 것"을 찾는 문제는 스택 패턴을 떠올리자
