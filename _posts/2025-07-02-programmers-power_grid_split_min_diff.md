---
title: "프로그래머스 전력망을 둘로 나누기 문제"
categories: [코딩테스트]
tags: [그래프, DFS, 완전탐색, Java]
date: 2025-07-02 10:00:00 +0900
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "counts"
---

## 🔌 문제 설명

프로그래머스 문제 "전력망을 둘로 나누기"는 전력망 네트워크에서 하나의 간선을 제거해 두 개의 전력망으로 나누었을 때, **두 전력망 간 송전탑 개수의 차이**를 최소로 만드는 문제입니다.

---

## 💡 풀이 아이디어

1. **간선을 하나씩 제거**하면서 그 상태의 전력망을 확인합니다.
2. 제거된 간선을 제외한 나머지 간선들로 그래프를 다시 구성합니다.
3. DFS를 이용하여 하나의 전력망에 연결된 송전탑 개수를 계산합니다.
4. 두 전력망 간 송전탑 개수 차이의 최솟값을 갱신합니다.

> 트리에서 간선 하나를 제거하면 항상 정확히 두 개의 트리(전력망)로 나뉘게 됩니다.

---

## 📄 자바 코드

```java
package Programmers;
import java.util.*;

public class Programmers6 {

    // 전력망을 두 개로 나눴을 때 송전탑 수 차이의 최소값을 구하는 함수
    public int solution(int n, int[][] wires) {
        int answer = n;  // 초기값은 최대 가능한 차이(n)로 설정

        // 모든 간선을 하나씩 끊어보면서 탐색
        for (int i = 0; i < wires.length; i++) {

            // 인접 리스트 형태로 그래프 초기화 (노드 번호는 1~n)
            List<List<Integer>> graph = new ArrayList<>();
            for (int j = 0; j <= n; j++) {
                graph.add(new ArrayList<>());
            }

            // i번째 간선을 끊고 나머지 간선들로 그래프를 구성
            for (int j = 0; j < wires.length; j++) {
                if (i == j) continue;  // i번째 간선은 끊은 상태이므로 무시
                int a = wires[j][0];
                int b = wires[j][1];

                // 양방향 간선 연결
                graph.get(a).add(b);
                graph.get(b).add(a);
            }

            // 방문 여부 체크 배열
            boolean[] visited = new boolean[n + 1];

            // 1번 노드를 기준으로 한 쪽 전력망의 송전탑 수를 DFS로 계산
            int count = dfs(1, graph, visited);

            // 다른 쪽은 전체 n에서 count를 뺀 값
            // 두 전력망의 송전탑 수 차이 계산
            int diff = Math.abs(n - count - count);

            // 최소 차이값 업데이트
            answer = Math.min(answer, diff);
        }

        return answer;  // 최소 차이값 반환
    }

    // DFS를 이용해 하나의 트리에 연결된 노드 개수 계산
    public int dfs(int node, List<List<Integer>> graph, boolean[] visited) {
        visited[node] = true; // 현재 노드 방문 표시
        int count = 1;        // 자기 자신 포함해서 카운트 시작

        // 현재 노드에 인접한 노드들 탐색
        for (int next : graph.get(node)) {
            if (!visited[next]) {
                // 인접 노드 중 방문하지 않은 노드에 대해 재귀적으로 DFS 호출
                count += dfs(next, graph, visited);
            }
        }

        return count;  // 이 노드와 연결된 전체 노드 수 반환
    }

}

```

---

## 🧠 흐름 요약

- 간선을 하나씩 제거하며 모든 경우를 시도한다.
- DFS로 전력망 하나의 송전탑 수를 계산한다.
- 나머지 송전탑 수는 `n - count`로 계산한다.
- 차이값 `|count - (n - count)|`을 구해 최소값을 갱신한다.

---

## 📌 예외 처리 및 주의 사항

- 노드는 **1번부터 시작**하므로 `visited[]`와 `graph[]`는 크기를 `n + 1`로 생성합니다.
- DFS는 항상 `1`번 노드에서 시작해도 괜찮습니다.
  - 간선을 하나 끊었을 때, 나머지 노드들과 연결된 하나의 트리이기 때문입니다.

---

## ⏱️ 시간 복잡도

- 간선 수만큼 반복: `O(n)`
- 각 경우마다 DFS 탐색: `O(n)`
- 전체 시간 복잡도: `O(n^2)` (최대 100 \* 100 = 10,000으로 충분히 가능)

---

## ✅ 정리

| 항목      | 설명                              |
| --------- | --------------------------------- |
| 그래프    | 인접 리스트 방식으로 구현         |
| 탐색 방식 | DFS                               |
| 반복 방식 | 모든 간선 제거 시도 (완전탐색)    |
| 핵심 목표 | 두 전력망 송전탑 개수 차이 최소화 |

---

## 🧠 핵심 로직 요약

| 개념      | 설명                                            |
| --------- | ----------------------------------------------- |
| 간선 제거 | 하나씩 제거하며 경우의 수 시도                  |
| DFS 탐색  | 한 노드에서 연결된 송전탑 개수 탐색             |
| 차이 계산 | 전체 - 탐색한 개수 - 탐색한 개수 = 두 트리 차이 |

---

## 🧪 예시 입력

```java
int n = 9;
int[][] wires = {
    {1, 3},
    {2, 3},
    {3, 4},
    {4, 5},
    {4, 6},
    {4, 7},
    {7, 8},
    {7, 9}
};
```

### ⚙️ 예시 그래프 구조

```
         1   2
          \ /
           3
            |
            4
         /  |  \
        5   6   7
                 \
                 8  9
```

---

## 🔍 간선 하나씩 끊으며 DFS 진행

### 📌 간선 (3,4)를 끊는 경우:

- DFS(1) → 방문: 3개 (1-3-2)
- 나머지: 6개 (4~9)
- 차이: |3 - 6| = **3**

### 📌 간선 (4,7)를 끊는 경우:

- DFS(1) → 방문: 5개
- 나머지: 4개
- 차이: |5 - 4| = **1** ✅ 최소값

---

## 🔁 전체 실행 흐름

| 끊은 간선 | dfs(1) 탐색 수 | 나머지 | 차이 |
| --------- | -------------- | ------ | ---- |
| (1,3)     | 8              | 1      | 7    |
| (2,3)     | 8              | 1      | 7    |
| (3,4)     | 3              | 6      | 3    |
| (4,5)     | 8              | 1      | 7    |
| (4,6)     | 8              | 1      | 7    |
| (4,7)     | 5              | 4      | ✅ 1 |
| (7,8)     | 8              | 1      | 7    |
| (7,9)     | 8              | 1      | 7    |

---

## ✅ 결과

```java
solution(9, wires) → return 1;
```

---

## ❗ 예외 처리 팁

- 노드는 1번부터 시작 → `boolean[] visited = new boolean[n + 1]`
- 트리에서 간선 하나만 끊으면 항상 두 트리로 나뉨 → `dfs(1)`만 해도 정확히 계산 가능

---
