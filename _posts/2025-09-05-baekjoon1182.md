---
title: "[백준 1182] - 부분수열의 합 - Java 풀이"
date: 2025-09-05
categories: [Baekjoon, Java]
tags: [브루트포스, DFS, 백트래킹, 부분수열, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 📌 문제 설명

정수로 이루어진 수열이 주어질 때, **부분수열의 원소 합이 특정 값 S와 같은 경우의 수**를 구하는 문제이다.  
단, 부분수열은 공집합도 포함하지만, 문제 조건에서는 공집합은 제외한다.

---

## 📜 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon1182 {
    // 전역 변수 선언
    static int N;         // 수열의 길이
    static int S;         // 목표 합
    static int[] s;       // 입력된 수열 저장 배열
    static int cnt = 0;   // 조건을 만족하는 부분수열의 개수 카운트

    public static void main(String[] args) throws IOException {
        // 입력을 빠르게 받기 위한 BufferedReader 사용
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 첫 줄: N과 S 입력 받기
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());  // 수열의 길이
        S = Integer.parseInt(st.nextToken());  // 목표 합

        // 수열을 저장할 배열 생성
        s = new int[N];

        // 두 번째 줄: 수열 입력 받기
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            s[i] = Integer.parseInt(st.nextToken());
        }

        // 부분수열 탐색 시작 (인덱스 0부터 시작, 합은 0으로 시작)
        dfs(0, 0);

        // S == 0일 경우, 공집합도 sum == 0이 되기 때문에 1개 빼줌
        if (S == 0) cnt--;

        // 정답 출력
        System.out.println(cnt);
    }

    // dfs: 현재 인덱스와 현재까지의 합을 받아서 모든 부분수열을 탐색
    static void dfs(int idx, int sum) {
        // 종료 조건: 수열의 끝까지 도달했을 때
        if (idx == N) {
            // 현재까지의 합이 S와 같으면 조건 만족 → 카운트 증가
            if (sum == S) {
                cnt++;
            }
            return; // 현재 재귀 호출 종료, 한 단계 위로 되돌아감
        }

        // 현재 원소 s[idx]를 **포함하는 경우**
        dfs(idx + 1, sum + s[idx]);

        // 현재 원소 s[idx]를 **포함하지 않는 경우**
        dfs(idx + 1, sum);
    }
}
```

---

## 🔑 핵심 로직 설명

1. DFS(깊이 우선 탐색)

- 각 원소에 대해 포함하는 경우와 포함하지 않는 경우를 모두 탐색한다.
- 즉, 모든 부분수열을 탐색하는 완전 탐색(Brute Force) 방식이다.

2. 공집합 처리

- 모든 원소를 포함하지 않는 경우(= 공집합)도 탐색에 포함된다.
- 만약 S == 0일 경우 공집합도 조건을 만족하기 때문에 cnt-- 처리를 해줘야 한다.

3. 전역 변수 사용 이유

- cnt는 전역으로 관리하여 재귀가 종료될 때마다 누적한다.

---

## 📊 시간 복잡도 분석

- DFS는 각 원소마다 포함 / 미포함 두 가지 경우를 탐색한다.

- 따라서 시간 복잡도는 O(2^N).

- 단, N ≤ 20 이므로 2^20 = 1,048,576 → 충분히 연산 가능.

---

## 🛠️ 사용한 자료구조 & 메서드

- 배열(int[]) : 입력된 수열 저장

- DFS 재귀 함수 : 모든 부분수열을 탐색

- BufferedReader & StringTokenizer : 빠른 입력 처리

---

## 💡 마무리 (느낀점 & 접근 방법)

이 문제는 DFS와 브루트포스의 기본기를 확인할 수 있는 문제였다.
처음에는 "단순히 합을 맞추면 되지 않을까?"라는 생각을 했지만, 실제로 구현해보니 부분수열 전체를 탐색해야 한다는 점이 중요했다.

- 접근 방법
  1. 각 원소를 포함할지 / 하지 않을지의 2가지 선택으로 모든 경우를 만든다.
  2. 합이 목표값 S와 같으면 카운트한다.
  3. 공집합 예외 처리를 꼭 해준다.

👉 이 문제를 풀면서 백트래킹과 완전탐색(Brute Force)의 차이를 다시 정리할 수 있었고,
DFS가 단순 탐색뿐만 아니라 조합/부분집합 문제 해결에도 매우 효과적임을 깨달았다.
