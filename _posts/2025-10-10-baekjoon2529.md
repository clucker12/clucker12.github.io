---
title: "[백준 2529] 부등호 문제 풀이 - Java"
date: 2025-10-10
categories: [Baekjoon, Java]
tags: [백트래킹, DFS, 브루트포스, 순열, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 💡 문제 개요

백준 **2529번 부등호** 문제는 주어진 부등호(`'<'`, `'>'`) 조건을 만족하는 **숫자 조합** 중에서  
가장 큰 수와 가장 작은 수를 찾는 문제입니다.

---

## 🔍 문제 접근 방법

이 문제는 단순히 숫자를 나열하는 것이 아니라,  
**부등호 조건**을 만족하도록 숫자를 조합해야 합니다.

즉, 각 부등호를 기준으로 두 숫자의 관계를 확인하면서 가능한 모든 조합을 만들어야 하므로,  
**백트래킹(DFS)** 방식을 사용합니다.

- `N`개의 부등호가 주어지면, 총 숫자는 `N+1`개가 됩니다.
- 숫자는 `0~9` 중 중복 없이 선택해야 합니다.
- 가능한 모든 경우의 수를 DFS로 탐색하면서 조건에 맞는 조합만 저장합니다.

---

## 📜 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.StringTokenizer;

public class baekjoon2529 {
    // 부등호의 개수 (숫자의 개수는 N+1이 됨)
    static int N;

    // 부등호 기호들을 저장할 배열
    static char[] sign;

    // 숫자 0~9 중에서 사용 여부를 체크하기 위한 배열
    static boolean[] visited = new boolean[10];

    // 조건을 만족하는 모든 숫자 조합을 저장할 리스트
    static List<String> result = new ArrayList<>();

    public static void main(String[] args) throws IOException {
        // 입력을 받기 위한 BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 부등호 개수 입력
        N = Integer.parseInt(br.readLine());

        // 부등호 입력 받아 배열에 저장
        sign = new char[N];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            sign[i] = st.nextToken().charAt(0);
        }

        // 깊이 우선 탐색 시작 (depth=0, 현재 숫자 문자열="")
        dfs(0, "");

        // 결과 리스트를 사전순 정렬
        Collections.sort(result);

        // 가장 큰 수 (마지막 원소)
        System.out.println(result.get(result.size() - 1));

        // 가장 작은 수 (첫 번째 원소)
        System.out.println(result.get(0));
    }

    /**
     * 깊이 우선 탐색 함수
     * @param depth 현재 깊이 (선택한 숫자의 개수)
     * @param num 현재까지 만든 숫자 문자열
     */
    static void dfs(int depth, String num) {
        // 숫자를 N+1개 선택했다면 결과 리스트에 추가
        if (depth == N + 1) {
            result.add(num);
            return;
        }

        // 0부터 9까지 숫자를 하나씩 시도
        for (int i = 0; i <= 9; i++) {
            // 아직 사용하지 않은 숫자라면
            if (!visited[i]) {
                // 첫 번째 숫자이거나, 이전 숫자와 부등호 조건을 만족할 경우만 진행
                if (depth == 0 || check(num.charAt(depth - 1) - '0', i, sign[depth - 1])) {
                    visited[i] = true;           // 숫자 사용 처리
                    dfs(depth + 1, num + i);     // 다음 자리로 재귀 호출
                    visited[i] = false;          // 백트래킹 (원상복구)
                }
            }
        }
    }

    /**
     * 부등호 조건을 검사하는 함수
     * @param a 이전 숫자
     * @param b 현재 숫자
     * @param op 부등호 문자 ('<' 또는 '>')
     * @return 조건을 만족하면 true, 아니면 false
     */
    static boolean check(int a, int b, char op) {
        if (op == '<') {
            return a < b;
        }
        if (op == '>') {
            return a > b;
        }
        return false;
    }
}

```

---

## 🧠 핵심 로직 및 주요 메서드

### 1️⃣ DFS (깊이 우선 탐색)

```java
static void dfs(int depth, String num) {
    if (depth == N + 1) {
        result.add(num);
        return;
    }

    for (int i = 0; i <= 9; i++) {
        if (!visited[i]) {
            if (depth == 0 || check(num.charAt(depth - 1) - '0', i, sign[depth - 1])) {
                visited[i] = true;
                dfs(depth + 1, num + i);
                visited[i] = false;
            }
        }
    }
}
```

- `depth`: 현재 선택한 숫자의 개수
- `num`: 현재까지 만든 숫자 문자열
- **백트래킹 구조**로, 조건 불만족 시 다시 돌아가 다른 숫자 시도

### 2️⃣ 부등호 검사 메서드

```java
static boolean check(int a, int b, char op) {
    if (op == '<') return a < b;
    if (op == '>') return a > b;
    return false;
}
```

- 간단하지만 핵심적인 부분입니다.
- 이전 숫자와 현재 숫자가 주어진 부등호 조건을 만족하는지 판별합니다.

---

## 🧩 주요 자료구조

| 자료구조              | 설명                                |
| --------------------- | ----------------------------------- |
| `boolean[] visited`   | 0~9 숫자 중 이미 사용된 숫자를 체크 |
| `char[] sign`         | 입력받은 부등호를 저장              |
| `List<String> result` | 조건을 만족하는 모든 숫자 조합 저장 |

---

## 🧮 시간 복잡도 분석

DFS로 가능한 모든 숫자 조합을 탐색하므로 최악의 경우는 다음과 같습니다:

- `O(10P(N+1))` ≈ `10!` (최대 3628800가지 조합)
- 하지만 부등호 조건에 따라 가지치기가 이루어져 **실제 탐색 수는 훨씬 적습니다.**

---

## 💬 느낀점 & 회고

이 문제는 **완전탐색과 백트래킹의 기본 구조**를 확실히 다질 수 있는 문제였습니다.  
단순히 모든 조합을 탐색하는 것이 아니라, **부등호 조건으로 가지치기를 적용하는 점**이 핵심입니다.

특히 `Collections.sort(result)`로 정렬하여 **최대값과 최소값을 쉽게 구하는 아이디어**가 인상적이었습니다.  
문제 자체는 간단하지만, **DFS의 동작 원리를 시각적으로 이해하기 좋은 문제**라 다시 복습하기에도 좋았습니다.

---
