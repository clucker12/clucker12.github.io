---
title: "[백준 11478] - 서로 다른 부분 문자열 개수 - Java 풀이"
date: 2025-08-11
categories: [Baekjoon, Java]
tags: [문자열, 자료구조, HashSet, 구현, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 문제 설명

문자열 S가 주어졌을 때, S의 서로 다른 부분 문자열의 개수를 구하는 문제입니다.

---

## 💻 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;

public class baekjoon11478 {
    public static void main(String[] args) throws IOException {
        // 입력을 받기 위한 BufferedReader 선언
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 문자열 S 입력 받기
        String S = br.readLine();

        // HashSet을 사용하여 중복 없는 부분 문자열 저장
        HashSet<String> set = new HashSet<>();

        // 문자열의 길이
        int len = S.length();

        // 부분 문자열의 길이 i를 1부터 len까지 반복
        for (int i = 1; i <= len; i++) {
            // 문자열 S의 시작 인덱스 j를 0부터 시작
            // 부분 문자열의 끝 인덱스 (j + i)가 len 이하일 때까지만 반복
            for (int j = 0; j + i <= len; j++) {
                // 부분 문자열을 잘라내어 set에 추가 (중복은 자동으로 제거됨)
                set.add(S.substring(j, j + i));
            }
        }

        // HashSet에 들어있는 서로 다른 부분 문자열의 개수 출력
        int result = set.size();
        System.out.println(result);
    }
}

```

---

## ⏱ 시간 복잡도 분석

- 문자열 길이를 N이라 하면,
- 부분 문자열 길이를 1부터 N까지 순회 → O(N)
- 각 길이에 대해 시작 인덱스를 이동하며 부분 문자열 생성 → O(N)
- 부분 문자열 생성은 `substring` 메서드로 O(k) (k는 부분 문자열 길이) 소요
- **총 시간 복잡도:** O(N³) (substring 비용까지 포함 시)
- 하지만, 문제의 N이 1000 이하이므로 완전 탐색 가능

---

## 📌 주요 메서드 및 핵심 로직

- **`HashSet<String>`**  
  서로 다른 부분 문자열만 저장하기 위해 사용 (자동 중복 제거 기능)
- **`substring(int start, int end)`**  
  문자열의 특정 구간을 잘라서 반환. start는 포함, end는 제외
- **이중 for문**으로 모든 부분 문자열 생성
  - 바깥 루프: 부분 문자열 길이
  - 안쪽 루프: 시작 인덱스

---

## 🗂 사용 자료구조

- **HashSet**
  - 중복 방지 + O(1) 평균 시간 복잡도로 삽입/탐색 가능
  - 정렬이 필요 없으므로 `TreeSet` 대신 `HashSet` 사용

---

## 💡 마무리

이 문제의 핵심은 **모든 부분 문자열을 탐색**하고, **중복 제거**하는 것입니다.  
중복 제거를 위해 Set 자료구조를 떠올릴 수 있어야 하며,  
문자열 처리에서는 `substring` 활용이 중요합니다.

---

## 🤔 느낀점 & 접근 방법

처음에는 단순히 모든 부분 문자열을 저장하면 될 것 같았지만,  
중복을 어떻게 처리할지에 대한 고민이 필요했습니다.  
Set을 사용하면 자동으로 중복 제거가 가능하므로, 구현이 매우 간단해집니다.

**접근 순서**

1. 모든 부분 문자열 생성
2. Set에 저장하여 중복 제거
3. Set의 크기 출력

이 문제를 풀면서, 문자열 문제에서는 **효율적인 자료구조 선택**이 풀이를 단순화시키는 핵심이라는 점을 다시 느꼈습니다.
