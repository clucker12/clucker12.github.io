---
title: "[ë°±ì¤€ 17471] ê²Œë¦¬ë§¨ë”ë§ (ì™„ì „ íƒìƒ‰ + BFS) - Java"
date: 2025-10-20
categories: [Baekjoon, Java]
tags: [BFS, ì™„ì „íƒìƒ‰, ì¡°í•©, ê·¸ë˜í”„, Java, ë°±ì¤€]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## ğŸ§© ë¬¸ì œ ì„¤ëª…

ë°±ì¤€ 17471ë²ˆ **ê²Œë¦¬ë§¨ë”ë§** ë¬¸ì œëŠ” `N`ê°œì˜ êµ¬ì—­ì„ ë‘ ê°œì˜ ì„ ê±°êµ¬ë¡œ ë‚˜ëˆ„ì–´,  
ê° ì„ ê±°êµ¬ê°€ **ëª¨ë‘ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ì„œ** ì¸êµ¬ ì°¨ì´ê°€ ìµœì†Œê°€ ë˜ë„ë¡ í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

ì¦‰, ë‘ êµ¬ì—­ ì§‘í•© A, Bë¥¼ ë§Œë“¤ ë•Œ ë‹¤ìŒ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ í•©ë‹ˆë‹¤.

1. ê° ì§‘í•©ì€ **ì ì–´ë„ í•˜ë‚˜ì˜ êµ¬ì—­ì„ í¬í•¨**í•´ì•¼ í•œë‹¤.
2. ê° ì§‘í•© ë‚´ êµ¬ì—­ì€ ëª¨ë‘ **ì„œë¡œ ì—°ê²°ë˜ì–´ ìˆì–´ì•¼ í•œë‹¤.**
3. ì¸êµ¬ ì°¨ì´ì˜ ìµœì†Ÿê°’ì„ êµ¬í•œë‹¤.

---

## ğŸ’¡ ì ‘ê·¼ ë°©ë²•

1. **ë¶€ë¶„ì§‘í•© ìƒì„± (ë¹„íŠ¸ë§ˆìŠ¤í¬)**

   - `1 ~ (1<<N)-2` ë²”ìœ„ì—ì„œ ëª¨ë“  ê°€ëŠ¥í•œ êµ¬ì—­ ì¡°í•©ì„ ìƒì„±í•©ë‹ˆë‹¤.
   - `0`(ê³µì§‘í•©)ê³¼ `ì „ì²´ì§‘í•©`ì€ ì œì™¸í•©ë‹ˆë‹¤.

2. **ê° ë¶€ë¶„ì§‘í•©ì„ ë‘ ê·¸ë£¹(A, B)ìœ¼ë¡œ ë¶„ë¦¬**

   - ë¹„íŠ¸ê°€ 1ì¸ êµ¬ì—­ì€ `A`, 0ì¸ êµ¬ì—­ì€ `B`ë¡œ ë¶„ë¥˜.

3. **ê° ê·¸ë£¹ì´ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ BFSë¡œ í™•ì¸**

   - ì—°ê²°ì´ ë˜ì–´ìˆì§€ ì•Šë‹¤ë©´ í•´ë‹¹ ì¡°í•©ì€ ë¬´ì‹œí•©ë‹ˆë‹¤.

4. **ë‘ ê·¸ë£¹ì˜ ì¸êµ¬ ì°¨ì´ ê³„ì‚° í›„ ìµœì†Œê°’ ê°±ì‹ **

---

## âš™ï¸ ì „ì²´ ì½”ë“œ

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class baekjoon17471 {
    static int N;                     // êµ¬ì—­ ê°œìˆ˜
    static int[] population;          // ê° êµ¬ì—­ ì¸êµ¬ìˆ˜ ì €ì¥ ë°°ì—´
    static List<Integer>[] adjList;   // ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ (ê° êµ¬ì—­ê³¼ ì—°ê²°ëœ êµ¬ì—­ ë²ˆí˜¸ë“¤)
    static int minDiff = Integer.MAX_VALUE; // ì¸êµ¬ ì°¨ì´ ìµœì†Œê°’ ì´ˆê¸°í™”

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 1. êµ¬ì—­ ê°œìˆ˜ ì…ë ¥
        N = Integer.parseInt(br.readLine());

        // ì¸êµ¬ìˆ˜ ë°°ì—´ í¬ê¸° ì„¤ì • (1ë²ˆ êµ¬ì—­ë¶€í„° ì‹œì‘í•˜ë¯€ë¡œ N+1)
        population = new int[N+1];

        // ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ë°°ì—´ ìƒì„±
        @SuppressWarnings("unchecked")
        List<Integer>[] tempList = (List<Integer>[]) new ArrayList[N + 1];
        adjList = tempList;

        // 2. ê° êµ¬ì—­ì˜ ì¸êµ¬ ì…ë ¥
        st= new StringTokenizer(br.readLine());
        for (int i = 1; i <= N; i++) {
            population[i] = Integer.parseInt(st.nextToken());
            adjList[i] = new ArrayList<>(); // ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
        }

        // 3. ê° êµ¬ì—­ë³„ ì¸ì ‘í•œ êµ¬ì—­ ì •ë³´ ì…ë ¥
        for (int i = 1; i <= N; i++) {
            st = new StringTokenizer(br.readLine());
            int cnt = Integer.parseInt(st.nextToken());  // ì¸ì ‘ êµ¬ì—­ ê°œìˆ˜
            for (int j = 0; j < cnt; j++) {
                int neighbor = Integer.parseInt(st.nextToken()); // ì¸ì ‘ êµ¬ì—­ ë²ˆí˜¸
                adjList[i].add(neighbor);                         // ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
            }
        }

        // 4. ë¶€ë¶„ ì§‘í•©ì„ ì´ìš©í•˜ì—¬ ë‘ ì„ ê±°êµ¬ë¡œ ë‚˜ëˆ„ê¸° (1ë¶€í„° (2^N)-2ê¹Œì§€)
        // (ëª¨ë“  êµ¬ì—­ì„ í¬í•¨í•˜ëŠ” ì§‘í•©ê³¼ ì•„ë¬´ê²ƒë„ í¬í•¨í•˜ì§€ ì•ŠëŠ” ì§‘í•© ì œì™¸)
        for (int i = 1; i < (1<<N) - 1; i++) {
            List<Integer> groupA = new ArrayList<>(); // ì²« ë²ˆì§¸ ì„ ê±°êµ¬ êµ¬ì—­ ë¦¬ìŠ¤íŠ¸
            List<Integer> groupB = new ArrayList<>(); // ë‘ ë²ˆì§¸ ì„ ê±°êµ¬ êµ¬ì—­ ë¦¬ìŠ¤íŠ¸

            // ê° ë¹„íŠ¸ë³„ë¡œ í¬í•¨ ì—¬ë¶€ í™•ì¸
            for (int j = 0; j < N; j++) {
                if ((i & (1 << j)) != 0) {
                    groupA.add(j + 1); // ë¹„íŠ¸ê°€ 1ì´ë©´ groupAì— í¬í•¨ (êµ¬ì—­ ë²ˆí˜¸ëŠ” j+1)
                } else {
                    groupB.add(j + 1); // ë¹„íŠ¸ê°€ 0ì´ë©´ groupBì— í¬í•¨
                }
            }

            // 5. ë‘ ê·¸ë£¹ ëª¨ë‘ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ ì¸êµ¬ ì°¨ì´ ê³„ì‚° ë° ìµœì†Œê°’ ê°±ì‹ 
            if(isConnected(groupA) && isConnected(groupB)){
                int diff = Math.abs(getPopulation(groupA) - getPopulation(groupB));
                minDiff = Math.min(minDiff, diff);
            }
        }

        // 6. ê²°ê³¼ ì¶œë ¥: ê°€ëŠ¥í•œ ë¶„í•  ì—†ìœ¼ë©´ -1, ìˆìœ¼ë©´ ìµœì†Œ ì¸êµ¬ ì°¨ì´ ì¶œë ¥
        System.out.println(minDiff == Integer.MAX_VALUE ? -1 : minDiff);
    }

    // íŠ¹ì • ê·¸ë£¹ì´ ê·¸ë˜í”„ìƒì—ì„œ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ì²´í¬í•˜ëŠ” í•¨ìˆ˜
    static boolean isConnected(List<Integer> group) {
        if(group.isEmpty()) return false; // ê·¸ë£¹ì´ ë¹„ì–´ìˆìœ¼ë©´ ì—°ê²° ë¶ˆê°€

        boolean[] visited = new boolean[N+1];   // ë°©ë¬¸ ì²´í¬ ë°°ì—´
        Queue<Integer> queue = new LinkedList<>();

        // ê·¸ë£¹ì˜ ì²« êµ¬ì—­ì„ ì‹œì‘ì ìœ¼ë¡œ BFS ìˆ˜í–‰
        queue.offer(group.get(0));
        visited[group.get(0)] = true;

        int cnt = 1; // BFSë¡œ ë°©ë¬¸í•œ êµ¬ì—­ ê°œìˆ˜

        while (!queue.isEmpty()){
            int current = queue.poll();

            // current êµ¬ì—­ê³¼ ì¸ì ‘í•œ êµ¬ì—­ íƒìƒ‰
            for (int neighbor : adjList[current]){
                // neighborê°€ groupì— í¬í•¨ë˜ê³  ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
                if(group.contains(neighbor) && !visited[neighbor]){
                    visited[neighbor] = true;
                    queue.offer(neighbor);
                    cnt++; // ë°©ë¬¸ êµ¬ì—­ ìˆ˜ ì¦ê°€
                }
            }
        }

        // BFS ë°©ë¬¸í•œ êµ¬ì—­ ìˆ˜ê°€ group í¬ê¸°ì™€ ê°™ìœ¼ë©´ ì—°ê²°ëœ ê·¸ë£¹ì„
        return cnt == group.size();
    }

    // ê·¸ë£¹ì— ì†í•œ êµ¬ì—­ë“¤ì˜ ì¸êµ¬ í•©ì„ êµ¬í•˜ëŠ” í•¨ìˆ˜
    static int getPopulation(List<Integer> group){
        int sum = 0;
        for (int i : group){
            sum += population[i];
        }
        return sum;
    }
}

```

---

## ğŸ§  í•µì‹¬ ë¡œì§

### âœ… BFSë¡œ ì—°ê²° ì—¬ë¶€ í™•ì¸

```java
static boolean isConnected(List<Integer> group) {
    if (group.isEmpty()) return false;

    boolean[] visited = new boolean[N+1];
    Queue<Integer> queue = new LinkedList<>();

    queue.offer(group.get(0));
    visited[group.get(0)] = true;
    int cnt = 1;

    while (!queue.isEmpty()) {
        int current = queue.poll();
        for (int neighbor : adjList[current]) {
            if (group.contains(neighbor) && !visited[neighbor]) {
                visited[neighbor] = true;
                queue.offer(neighbor);
                cnt++;
            }
        }
    }

    return cnt == group.size();
}
```

- `group`ì— í¬í•¨ëœ êµ¬ì—­ë“¤ë§Œ BFS íƒìƒ‰.
- ë°©ë¬¸í•œ ê°œìˆ˜ê°€ group í¬ê¸°ì™€ ë™ì¼í•˜ë©´ **ì—°ê²°ëœ ê·¸ë˜í”„**.

---

## ğŸ§® ì‹œê°„ ë³µì¡ë„ ë¶„ì„

- **ë¶€ë¶„ì§‘í•© íƒìƒ‰:** `2^N` (ìµœëŒ€ 10~20ì •ë„ì´ë¯€ë¡œ ê°€ëŠ¥)
- **BFS íƒìƒ‰:** `O(N + E)`
- **ì´í•©:** `O(2^N * (N + E))` â†’ ì™„ì „íƒìƒ‰ ê°€ëŠ¥ ë²”ìœ„.

---

## ğŸ“š ì£¼ìš” ìë£Œêµ¬ì¡°

| ìë£Œí˜•                    | ì—­í•                           |
| ------------------------- | ----------------------------- |
| `List<Integer>[] adjList` | ê° êµ¬ì—­ì˜ ì¸ì ‘ êµ¬ì—­ ì •ë³´ ì €ì¥ |
| `boolean[] visited`       | BFS ë°©ë¬¸ ì²´í¬                 |
| `Queue<Integer>`          | BFS íƒìƒ‰ìš© í                 |
| `List<Integer>`           | ì„ ê±°êµ¬ ê·¸ë£¹ ë¶„í•  ì €ì¥         |

---

## ğŸ’¬ ëŠë‚€ì 

ì´ ë¬¸ì œëŠ” ë‹¨ìˆœíˆ ë‘ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ê²Œ ì•„ë‹ˆë¼,  
ê° ê·¸ë£¹ì´ **ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ì—¬ë¶€**ê¹Œì§€ ê³ ë ¤í•´ì•¼ í•´ì„œ ë‹¨ìˆœ ì¡°í•© ë¬¸ì œë³´ë‹¤ í•œ ë‹¨ê³„ ë” ê¹Šì—ˆìŠµë‹ˆë‹¤.

ë¹„íŠ¸ë§ˆìŠ¤í¬ë¡œ ê°€ëŠ¥í•œ ì¡°í•©ì„ íš¨ìœ¨ì ìœ¼ë¡œ ìƒì„±í•˜ê³ , BFSë¡œ ì—°ê²°ì„±ì„ ê²€ì¦í•˜ëŠ” ì ‘ê·¼ì€  
**ê·¸ë˜í”„ íƒìƒ‰ê³¼ ì¡°í•© ë…¼ë¦¬ì˜ ìœµí•©**ì´ë¼ëŠ” ì ì—ì„œ í¥ë¯¸ë¡œì› ìŠµë‹ˆë‹¤.

íŠ¹íˆ â€œë¶€ë¶„ì§‘í•© ìƒì„± + BFS ê²€ì¦â€ êµ¬ì¡°ëŠ” ë‹¤ë¥¸ ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„± ë¬¸ì œì—ë„ ìœ ìš©í•˜ê²Œ ì ìš©ë  ìˆ˜ ìˆì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤.

---

ğŸ§­ **íŒŒì¼ ì´ë¦„:** `2025-10-20-baekjoon17471.md`
