---
title: "[백준 17471] 게리맨더링 (완전 탐색 + BFS) - Java"
date: 2025-10-20
categories: [Baekjoon, Java]
tags: [BFS, 완전탐색, 조합, 그래프, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 🧩 문제 설명

백준 17471번 **게리맨더링** 문제는 `N`개의 구역을 두 개의 선거구로 나누어,  
각 선거구가 **모두 연결되어 있으면서** 인구 차이가 최소가 되도록 하는 문제입니다.

즉, 두 구역 집합 A, B를 만들 때 다음 조건을 만족해야 합니다.

1. 각 집합은 **적어도 하나의 구역을 포함**해야 한다.
2. 각 집합 내 구역은 모두 **서로 연결되어 있어야 한다.**
3. 인구 차이의 최솟값을 구한다.

---

## 💡 접근 방법

1. **부분집합 생성 (비트마스크)**

   - `1 ~ (1<<N)-2` 범위에서 모든 가능한 구역 조합을 생성합니다.
   - `0`(공집합)과 `전체집합`은 제외합니다.

2. **각 부분집합을 두 그룹(A, B)으로 분리**

   - 비트가 1인 구역은 `A`, 0인 구역은 `B`로 분류.

3. **각 그룹이 연결되어 있는지 BFS로 확인**

   - 연결이 되어있지 않다면 해당 조합은 무시합니다.

4. **두 그룹의 인구 차이 계산 후 최소값 갱신**

---

## ⚙️ 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class baekjoon17471 {
    static int N;                     // 구역 개수
    static int[] population;          // 각 구역 인구수 저장 배열
    static List<Integer>[] adjList;   // 인접 리스트 (각 구역과 연결된 구역 번호들)
    static int minDiff = Integer.MAX_VALUE; // 인구 차이 최소값 초기화

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 1. 구역 개수 입력
        N = Integer.parseInt(br.readLine());

        // 인구수 배열 크기 설정 (1번 구역부터 시작하므로 N+1)
        population = new int[N+1];

        // 인접 리스트 배열 생성
        @SuppressWarnings("unchecked")
        List<Integer>[] tempList = (List<Integer>[]) new ArrayList[N + 1];
        adjList = tempList;

        // 2. 각 구역의 인구 입력
        st= new StringTokenizer(br.readLine());
        for (int i = 1; i <= N; i++) {
            population[i] = Integer.parseInt(st.nextToken());
            adjList[i] = new ArrayList<>(); // 인접 리스트 초기화
        }

        // 3. 각 구역별 인접한 구역 정보 입력
        for (int i = 1; i <= N; i++) {
            st = new StringTokenizer(br.readLine());
            int cnt = Integer.parseInt(st.nextToken());  // 인접 구역 개수
            for (int j = 0; j < cnt; j++) {
                int neighbor = Integer.parseInt(st.nextToken()); // 인접 구역 번호
                adjList[i].add(neighbor);                         // 인접 리스트에 추가
            }
        }

        // 4. 부분 집합을 이용하여 두 선거구로 나누기 (1부터 (2^N)-2까지)
        // (모든 구역을 포함하는 집합과 아무것도 포함하지 않는 집합 제외)
        for (int i = 1; i < (1<<N) - 1; i++) {
            List<Integer> groupA = new ArrayList<>(); // 첫 번째 선거구 구역 리스트
            List<Integer> groupB = new ArrayList<>(); // 두 번째 선거구 구역 리스트

            // 각 비트별로 포함 여부 확인
            for (int j = 0; j < N; j++) {
                if ((i & (1 << j)) != 0) {
                    groupA.add(j + 1); // 비트가 1이면 groupA에 포함 (구역 번호는 j+1)
                } else {
                    groupB.add(j + 1); // 비트가 0이면 groupB에 포함
                }
            }

            // 5. 두 그룹 모두 연결되어 있으면 인구 차이 계산 및 최소값 갱신
            if(isConnected(groupA) && isConnected(groupB)){
                int diff = Math.abs(getPopulation(groupA) - getPopulation(groupB));
                minDiff = Math.min(minDiff, diff);
            }
        }

        // 6. 결과 출력: 가능한 분할 없으면 -1, 있으면 최소 인구 차이 출력
        System.out.println(minDiff == Integer.MAX_VALUE ? -1 : minDiff);
    }

    // 특정 그룹이 그래프상에서 연결되어 있는지 체크하는 함수
    static boolean isConnected(List<Integer> group) {
        if(group.isEmpty()) return false; // 그룹이 비어있으면 연결 불가

        boolean[] visited = new boolean[N+1];   // 방문 체크 배열
        Queue<Integer> queue = new LinkedList<>();

        // 그룹의 첫 구역을 시작점으로 BFS 수행
        queue.offer(group.get(0));
        visited[group.get(0)] = true;

        int cnt = 1; // BFS로 방문한 구역 개수

        while (!queue.isEmpty()){
            int current = queue.poll();

            // current 구역과 인접한 구역 탐색
            for (int neighbor : adjList[current]){
                // neighbor가 group에 포함되고 방문하지 않았다면
                if(group.contains(neighbor) && !visited[neighbor]){
                    visited[neighbor] = true;
                    queue.offer(neighbor);
                    cnt++; // 방문 구역 수 증가
                }
            }
        }

        // BFS 방문한 구역 수가 group 크기와 같으면 연결된 그룹임
        return cnt == group.size();
    }

    // 그룹에 속한 구역들의 인구 합을 구하는 함수
    static int getPopulation(List<Integer> group){
        int sum = 0;
        for (int i : group){
            sum += population[i];
        }
        return sum;
    }
}

```

---

## 🧠 핵심 로직

### ✅ BFS로 연결 여부 확인

```java
static boolean isConnected(List<Integer> group) {
    if (group.isEmpty()) return false;

    boolean[] visited = new boolean[N+1];
    Queue<Integer> queue = new LinkedList<>();

    queue.offer(group.get(0));
    visited[group.get(0)] = true;
    int cnt = 1;

    while (!queue.isEmpty()) {
        int current = queue.poll();
        for (int neighbor : adjList[current]) {
            if (group.contains(neighbor) && !visited[neighbor]) {
                visited[neighbor] = true;
                queue.offer(neighbor);
                cnt++;
            }
        }
    }

    return cnt == group.size();
}
```

- `group`에 포함된 구역들만 BFS 탐색.
- 방문한 개수가 group 크기와 동일하면 **연결된 그래프**.

---

## 🧮 시간 복잡도 분석

- **부분집합 탐색:** `2^N` (최대 10~20정도이므로 가능)
- **BFS 탐색:** `O(N + E)`
- **총합:** `O(2^N * (N + E))` → 완전탐색 가능 범위.

---

## 📚 주요 자료구조

| 자료형                    | 역할                          |
| ------------------------- | ----------------------------- |
| `List<Integer>[] adjList` | 각 구역의 인접 구역 정보 저장 |
| `boolean[] visited`       | BFS 방문 체크                 |
| `Queue<Integer>`          | BFS 탐색용 큐                 |
| `List<Integer>`           | 선거구 그룹 분할 저장         |

---

## 💬 느낀점

이 문제는 단순히 두 그룹으로 나누는 게 아니라,  
각 그룹이 **연결되어 있는지 여부**까지 고려해야 해서 단순 조합 문제보다 한 단계 더 깊었습니다.

비트마스크로 가능한 조합을 효율적으로 생성하고, BFS로 연결성을 검증하는 접근은  
**그래프 탐색과 조합 논리의 융합**이라는 점에서 흥미로웠습니다.

특히 “부분집합 생성 + BFS 검증” 구조는 다른 네트워크 연결성 문제에도 유용하게 적용될 수 있을 것 같습니다.

---

🧭 **파일 이름:** `2025-10-20-baekjoon17471.md`
