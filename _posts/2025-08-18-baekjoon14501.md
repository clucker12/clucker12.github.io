---
title: "[백준 14501] - 퇴사 문제 풀이 - Java DP 풀이"
date: 2025-08-18
categories: [Baekjoon, Java]
tags: [DP, 동적계획법, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 📌 문제 설명

백준 **14501 - 퇴사** 문제는 퇴사 전까지 상담을 진행하여 얻을 수 있는 최대 수익을 구하는 문제입니다.  
각 날짜마다 상담을 진행하면 일정 기간 동안 상담을 해야 하며, 그만큼의 수익을 얻게 됩니다.  
단, 퇴사일을 넘기면 상담을 할 수 없습니다.

---

# 🖥️ 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class baekjoon14501 {
    public static void main(String[] args) throws IOException {
        // 빠른 입력을 위한 BufferedReader 사용
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 총 상담 가능한 날짜 수 (퇴사는 N+1일)
        int N = Integer.parseInt(br.readLine());

        // 각 날짜별 상담에 걸리는 기간 (1-indexed)
        int[] T = new int[N + 1];

        // 각 날짜별 상담으로 얻을 수 있는 수익 (1-indexed)
        int[] P = new int[N + 1];

        // DP 배열: dp[i] = i일까지 얻을 수 있는 최대 수익
        // 배열 크기를 넉넉히 N+7로 설정 (N+2면 충분하지만 여유 있게)
        int[] dp = new int[N + 7];

        // T[i], P[i] 입력 받기
        for (int i = 1; i <= N; i++) {
            String[] input = br.readLine().split(" ");
            T[i] = Integer.parseInt(input[0]);  // 상담 기간
            P[i] = Integer.parseInt(input[1]);  // 상담 수익
        }

        // DP 계산: 1일부터 N일까지 순회
        for (int i = 1; i <= N; i++) {
            // 1. 상담하지 않는 경우:
            //    다음 날로 수익을 그대로 넘김 (현재까지 수익 유지)
            dp[i + 1] = Math.max(dp[i + 1], dp[i]);

            // 2. 상담하는 경우:
            //    상담을 끝낼 수 있는 날짜가 퇴사 전이면
            if (i + T[i] <= N + 1) {
                // 상담이 끝나는 날에 수익을 갱신
                dp[i + T[i]] = Math.max(dp[i + T[i]], dp[i] + P[i]);
            }
        }

        // dp 배열 중 최대 수익을 찾음
        int max = 0;
        for (int i = 1; i <= N + 1; i++) {
            max = Math.max(max, dp[i]);
        }

        // 최대 수익 출력
        System.out.println(max);
    }
}

```

---

# ⚙️ 풀이 과정

1. **DP 배열 정의**  
   `dp[i] = i일 까지 얻을 수 있는 최대 수익`

2. **상담하지 않는 경우**  
   👉 `dp[i+1] = max(dp[i+1], dp[i])`

3. **상담하는 경우**  
   👉 `dp[i + T[i]] = max(dp[i + T[i]], dp[i] + P[i])`  
   단, `i + T[i] <= N+1` 이어야 함 (퇴사 전 상담 종료 조건)

---

# 🕒 시간 복잡도

- 입력 크기: `N (1 ≤ N ≤ 15)`
- 각 날짜마다 상수 시간 연산 수행 → **O(N)**

---

# 📌 주요 메서드 & 핵심 로직

- **BufferedReader** : 빠른 입력 처리
- **DP 배열 (`dp`)** : 상담을 진행했을 때와 진행하지 않았을 때의 수익을 갱신
- **Math.max()** : 두 선택지 중 최대값을 선택

---

# 🗂️ 사용 자료구조

- **배열 (T, P, dp)**
  - `T[i]` : i번째 상담에 걸리는 기간
  - `P[i]` : i번째 상담의 수익
  - `dp[i]` : i일까지 얻을 수 있는 최대 수익

---

# 💡 마무리

이 문제는 **DP(동적 계획법)** 의 기본적인 아이디어인  
👉 "현재 선택이 미래 결과에 영향을 준다" 를 잘 보여줍니다.

퇴사일이라는 **명확한 제한 조건** 때문에 단순히 탐욕적으로 선택하면 오답이 나오고,  
모든 선택지를 고려하면서 최적해를 찾아야 하기 때문에 **DP 접근**이 필요합니다.

---

# ✨ 느낀점

이 문제를 풀면서 "부분 문제를 정의하고, 그 해를 이용해 더 큰 문제를 해결하는 과정"이  
얼마나 중요한지 다시 한번 느꼈습니다.

단순히 그날의 최대 이익만 보는 것이 아니라,  
**앞으로의 일정까지 고려해야 한다는 점**에서 **일정 관리 최적화 문제**와 유사하다고 생각했습니다.

👉 DP 문제를 풀 때는 **현재 상태 정의(dp[i])** 와  
**다음 상태 전이(dp[i+1], dp[i+T[i]])** 를 명확히 세우는 것이 핵심입니다.
