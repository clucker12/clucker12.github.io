---
title: "[백준 3190] - 뱀 - Java 풀이"
date: 2025-08-04
categories: [Baekjoon, Java]
tags: [자료구조, 구현, 시뮬레이션, 뱀, Deque, HashMap, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 📌 문제 설명

- NxN 보드 위에서 뱀이 움직이며 사과를 먹는 시뮬레이션 문제
- 방향 전환 명령이 주어지고, 뱀이 벽 또는 자기 자신과 부딪히면 게임이 끝남
- 게임이 끝나는 시간을 출력

**문제 링크**: [백준 3190번 - 뱀](https://www.acmicpc.net/problem/3190)

---

## ✅ 코드 구현

```java
package Baekjoon;

import java.io.*;
import java.util.*;

public class baekjoon3190 {
    static int N; // 보드 크기
    static Deque<int[]> snake = new ArrayDeque<>(); // 뱀의 몸 좌표를 저장 (머리: 앞, 꼬리: 뒤)
    static HashMap<Integer, Character> change = new HashMap<>(); // 방향 전환 정보 저장 (시간 -> 'L' 또는 'D')
    static int[][] board; // 보드 상태 (0: 빈 칸, 1: 사과, 2: 뱀 몸)

    // 이동 방향 (오른쪽, 아래, 왼쪽, 위 순서)
    static int[] dx = {0, 1, 0, -1};
    static int[] dy = {1, 0, -1, 0};

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        N = Integer.parseInt(br.readLine()); // 보드 크기 입력
        board = new int[N][N]; // 보드 초기화

        int K = Integer.parseInt(br.readLine()); // 사과 개수
        for (int i = 0; i < K; i++) {
            String[] input = br.readLine().split(" ");
            int x = Integer.parseInt(input[0]); // 행
            int y = Integer.parseInt(input[1]); // 열
            board[x - 1][y - 1] = 1; // 사과 위치 표시
        }

        int L = Integer.parseInt(br.readLine()); // 방향 전환 횟수
        for (int i = 0; i < L; i++) {
            String[] input = br.readLine().split(" ");
            int X = Integer.parseInt(input[0]);
            char C = input[1].charAt(0);
            change.put(X, C);
        }

        System.out.println(run());
    }

    static int run() {
        int time = 0; // 시간
        int move = 0; // 현재 방향 (0: 오른쪽)
        int x = 0, y = 0;

        snake.add(new int[]{x, y});
        board[x][y] = 2;

        while (true) {
            time++;
            int nx = x + dx[move];
            int ny = y + dy[move];

            if (nx < 0 || ny < 0 || nx >= N || ny >= N || board[nx][ny] == 2) break;

            if (board[nx][ny] == 1) {
                board[nx][ny] = 2;
                snake.addFirst(new int[]{nx, ny});
            } else {
                board[nx][ny] = 2;
                snake.addFirst(new int[]{nx, ny});
                int[] tail = snake.removeLast();
                board[tail[0]][tail[1]] = 0;
            }

            if (change.containsKey(time)) {
                char c = change.get(time);
                if (c == 'D') move = (move + 1) % 4;
                else move = (move + 3) % 4;
            }

            x = nx;
            y = ny;
        }

        return time;
    }
}
```

---

## 🔍 주요 자료구조 설명

- **Deque<int[]> snake**: 뱀의 몸 좌표를 저장 (머리: 앞, 꼬리: 뒤)
- **HashMap<Integer, Character> change**: 시간에 따른 방향 전환 명령 저장
- **board[N][N]**: 보드 상태 (0: 빈 칸, 1: 사과, 2: 뱀)

---

## ⏱ 시간 복잡도

- 보드 크기: N x N
- 각 초마다 뱀이 한 칸 이동 → **최대 N²번 이동**
- 각 이동 시 O(1) 연산 → **총 O(N²)**

---

## 🧠 핵심 로직

1. **Deque로 뱀 관리**
   - 머리: `addFirst()`, 꼬리: `removeLast()`
2. **방향 전환**
   - `HashMap`으로 시간 → 명령 매핑
3. **충돌 체크**
   - 벽 또는 자기 몸에 닿으면 종료
4. **사과 처리**
   - 사과가 있으면 꼬리 제거 X, 없으면 꼬리 제거 O

---

## 💡 마무리 & 느낀점

- 뱀 게임 구현은 **상태 관리(위치, 방향, 시간)**가 핵심
- 방향 전환과 충돌 체크 로직이 까다로웠음
- **Deque를 사용하여 O(1)로 머리와 꼬리 관리 가능**
- 처음에는 배열로 뱀을 구현하려 했으나 비효율적 → **Deque 사용이 정답**
- 느낀 점: **방향 설정과 회전 구현이 핵심** + 다양한 예외 상황을 고려해야 함
