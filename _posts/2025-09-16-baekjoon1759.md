---
title: "[백준 1759] - 암호 만들기 문제 풀이 - Java"
date: 2025-09-16
categories: [Baekjoon, Java]
tags: [백트래킹, 조합, 브루트포스, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 📌 문제 설명

백준 1759번 **암호 만들기** 문제는 주어진 C개의 알파벳 중에서 길이가 L인 암호를 만드는 문제입니다.  
암호는 **모음 1개 이상**과 **자음 2개 이상**을 반드시 포함해야 하며, **사전 순**으로 출력해야 합니다.

---

## 📂 전체 코드

```java
package Baekjoon; // 패키지 이름 (문제에 따라 생략 가능)

// 필요한 라이브러리 임포트
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.StringTokenizer;

public class baekjoon1759 {
    // 암호의 길이 (선택할 문자 수)
    static int L;
    // 주어진 문자 수
    static int C;

    // 전체 문자 배열 (C개의 문자 저장)
    static char[] chars;
    // 선택된 문자(암호) 저장 배열 (길이 L)
    static char[] password;

    // 모음 저장 집합 (빠른 검사 위해 Set 사용)
    static Set<Character> mo = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));

    public static void main(String[] args) throws IOException {
        // 빠른 입력을 위한 BufferedReader 사용
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 첫 줄 입력: L과 C 읽기
        st = new StringTokenizer(br.readLine());
        L = Integer.parseInt(st.nextToken()); // 선택할 문자 수
        C = Integer.parseInt(st.nextToken()); // 전체 주어진 문자 수

        // 두 번째 줄: C개의 문자 읽기
        chars = new char[C];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < C; i++) {
            // 각 단어의 첫 글자(charAt(0))를 char로 저장
            chars[i] = st.nextToken().charAt(0);
        }

        // 문자 배열을 오름차순 정렬 → 사전순 조합 생성을 위해
        Arrays.sort(chars);

        // 암호를 저장할 배열 초기화
        password = new char[L];

        // 조합 생성 시작 (start index = 0, depth = 0)
        backtrack(0, 0);
    }

    // 백트래킹 함수
    static void backtrack(int start, int depth) {
        // 길이가 L인 조합이 완성된 경우
        if (depth == L) {
            // 모음 1개 이상, 자음 2개 이상인지 검사
            if (isValid(password)) {
                // 유효한 조합이면 출력
                System.out.println(new String(password));
            }
            return; // 조합 하나 마쳤으므로 백트래킹
        }

        // start부터 C까지 순차적으로 문자 선택
        for (int i = start; i < C; i++) {
            password[depth] = chars[i]; // 현재 위치에 문자 저장
            backtrack(i + 1, depth + 1); // 다음 문자 선택 (재귀)
        }
    }

    // 유효성 검사 함수: 모음 1개 이상, 자음 2개 이상인지 확인
    static boolean isValid(char[] pwd) {
        int mocnt = 0, jacnt = 0; // 모음/자음 개수

        for (char c : pwd) {
            if (mo.contains(c)) {
                mocnt++; // 모음 개수 증가
            } else {
                jacnt++; // 자음 개수 증가
            }
        }

        // 모음 1개 이상, 자음 2개 이상일 때 true
        return mocnt >= 1 && jacnt >= 2;
    }
}

```

---

## 🔑 핵심 로직

- 문자들을 **정렬** 후, **조합(Combination)**을 생성
- **조건 검사**: 모음 ≥ 1, 자음 ≥ 2

---

## 💡 접근 방법

1. **브루트포스 + 백트래킹**을 사용합니다.
2. 주어진 문자들을 **정렬**하여 사전순 출력을 자연스럽게 만듭니다.
3. 조합을 생성하면서 **모음 1개 이상 & 자음 2개 이상** 조건을 만족하는지 검사합니다.

---

## 🛠️ 사용 알고리즘 & 자료구조

- **백트래킹(Backtracking)**: 모든 조합을 탐색하면서 조건을 만족하는 경우만 출력
- **Set<Character>**: 모음 판별을 위해 사용
- **char[]**: 문자 배열을 사용해 현재 선택한 암호를 저장

---

## ⏱️ 시간 복잡도

- 전체 경우의 수는 **조합 C(C, L)**.
- 각 조합마다 모음/자음 개수를 확인하므로 O(L).
- **총 시간 복잡도**: `O(C choose L * L)` → 주어진 C 최대가 15라 충분히 빠릅니다.

---

## 💻 주요 코드 및 설명

```java
// 백트래킹을 이용해 조합 생성
static void backtrack(int start, int depth) {
    if (depth == L) { // 길이 L의 암호 완성
        if (isValid(password)) {
            System.out.println(new String(password)); // 출력
        }
        return;
    }
    for (int i = start; i < C; i++) {
        password[depth] = chars[i];
        backtrack(i + 1, depth + 1); // 다음 문자 선택
    }
}
```

- `backtrack`: start 인덱스부터 시작해 **사전순 조합**을 만든다.
- `isValid`: 모음 1개 이상, 자음 2개 이상인지 검사한다.

---

## 📝 느낀점

이 문제는 **조합**을 직접 구현하고 조건 검사를 통해 필터링하는 전형적인 백트래킹 문제였습니다.  
사전 순 출력을 위해 **정렬 후 조합 탐색**을 적용한 점이 핵심이었으며, 모음/자음 조건만 잘 체크하면 비교적 간단하게 해결할 수 있었습니다.  
코드의 흐름을 간결하게 유지하며 **DFS 백트래킹**을 구현하는 좋은 연습이 되었습니다.
