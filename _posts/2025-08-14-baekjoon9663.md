---
title: "[백준 9663] - N-Queen 문제 풀이 - Java 풀이"
date: 2025-08-14
categories: [Baekjoon, Java]
tags: [백트래킹, 구현, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 📌 문제 설명

**백준 9663 N-Queen 문제**는 N×N 체스판 위에 N개의 퀸을 서로 공격할 수 없도록 배치하는 경우의 수를 구하는 문제입니다.  
퀸은 같은 행, 같은 열, 같은 대각선 위에 있는 모든 말을 공격할 수 있습니다.

---

## 💡 접근 방법

- **백트래킹(Backtracking)**을 사용하여 퀸을 한 행씩 배치합니다.
- 각 단계에서 **유효성 검사**를 통해 불가능한 경우를 가지치기(Pruning)하여 탐색 효율을 높입니다.
- 공격 가능 여부를 확인하기 위해 3개의 배열(`col`, `diag1`, `diag2`)을 사용합니다.

---

## 📂 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class baekjoon9663 {
    static int N;               // 체스판의 크기 (N x N)
    static int count = 0;       // 정답 개수를 저장하는 변수
    static boolean[] col;       // 열에 퀸이 있는지 여부 체크
    static boolean[] diag1;     // / 방향 대각선 (↗↙) 체크: row + col
    static boolean[] diag2;     // \ 방향 대각선 (↖↘) 체크: row - col + (N - 1)

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());  // 사용자로부터 체스판 크기 N 입력받음

        col = new boolean[N];             // 각 열에 퀸이 있는지 체크 (0 ~ N-1)
        diag1 = new boolean[2 * N - 1];   // / 대각선은 최대 (row + col) = 2N - 2 → 인덱스 범위 0 ~ 2N - 2
        diag2 = new boolean[2 * N - 1];   // \ 대각선은 row - col 값이 -N+1 ~ N-1 → 양수로 바꾸기 위해 + N - 1

        backtrack(0);                     // 첫 번째 행부터 퀸을 놓기 시작
        System.out.println(count);       // 가능한 배치 수 출력
    }

    static void backtrack(int row) {
        // row == N 이면 모든 행에 퀸을 놓은 것이므로 경우 1개 완료
        if (row == N) {
            count++;
            return;
        }

        // 현재 행(row)의 모든 열(c)을 순회하며 퀸을 놓을 수 있는지 확인
        for (int c = 0; c < N; c++) {
            // 아래 조건 중 하나라도 true이면 퀸을 놓을 수 없음 → continue로 건너뜀
            if (col[c] || diag1[row + c] || diag2[row - c + N - 1])
                continue;

            // 퀸 놓기 → 현재 위치 (row, c)
            col[c] = true;                  // 열 사용 표시
            diag1[row + c] = true;          // / 대각선 사용 표시
            diag2[row - c + N - 1] = true;  // \ 대각선 사용 표시

            backtrack(row + 1);             // 다음 행으로 이동

            // 백트래킹: 놓았던 퀸을 제거하고 다른 위치 탐색
            col[c] = false;                 // 열 사용 해제
            diag1[row + c] = false;         // / 대각선 사용 해제
            diag2[row - c + N - 1] = false; // \ 대각선 사용 해제
        }
    }
}

```

---

## 🛠 주요 메서드 & 핵심 로직

### `backtrack(int row)`

- 한 행씩 퀸을 놓으며, **공격 가능 여부**를 검사
- 유효하지 않으면 해당 경우는 탐색하지 않고 다음 열로 넘어감
- 모든 행에 퀸을 배치하면 경우의 수 증가

---

## 📊 자료구조 설명

- `boolean[] col` : 각 열에 퀸이 있는지 여부 저장
- `boolean[] diag1` : `/` 방향 대각선 점유 여부 저장 (row + col)
- `boolean[] diag2` : `\` 방향 대각선 점유 여부 저장 (row - col + N - 1)

---

## ⏳ 시간 복잡도

- 최악의 경우 **O(N!)**
- 백트래킹과 Pruning을 통해 실제 연산량은 크게 줄어듦

---

## 📝 느낀점 (2025-08-14)

이 문제를 풀면서 **백트래킹의 가지치기**가 얼마나 효율을 높이는지 체감했습니다.  
단순히 모든 경우를 시도하는 것이 아니라, 불가능한 경로는 미리 차단하는 것이 핵심이라는 것을 다시 느꼈습니다.  
N-Queen 문제는 전형적인 백트래킹 문제이지만, 대각선 체크를 배열 인덱스 계산으로 처리하면 구현이 훨씬 깔끔해진다는 점이 인상 깊었습니다.
