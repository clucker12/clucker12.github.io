---
title: "프로그래머스 사전 만들기 문제"
categories: [코딩테스트]
tags: [완전탐색, Java, 사전순 탐색]
date: 2025-07-03 10:00:00 +0900
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "counts"
---

## 📘 문제 설명

주어진 단어가 모음(A, E, I, O, U)으로만 구성된 사전에 있을 때, 그 단어가 몇 번째에 위치하는지를 구하는 문제입니다. (최대 길이: 5)

## 예: A, AA, AAA, AAAA, AAAAA, ..., UUUUU 와 같은 사전에서 "EIO"는 몇 번째인지 구합니다.

## 💡 풀이 핵심 아이디어

각 자리는 5진법 가중치를 가지고 있음

자리별 최대 경우의 수:

1자리: 5^4 + 5^3 + 5^2 + 5^1 + 5^0 = 781

2자리: 5^3 + 5^2 + 5^1 + 5^0 = 156

3자리: 5^2 + 5^1 + 5^0 = 31

4자리: 5^1 + 5^0 = 6

5자리: 5^0 = 1

각 글자마다 그 앞에 몇 개의 단어가 오는지를 계산하여 누적합으로 더함

## 인덱스 + 1 은 자기 자신을 포함하기 위함

## 📄 자바 풀이 코드

```
package Programmers;

public class Programmers7 {
    public int solution(String word) {
        int answer = 0;

        // 각 자리별 가중치 배열
        // 1번째 자리: 5^4 + 5^3 + 5^2 + 5^1 + 5^0 = 781
        // 2번째 자리: 5^3 + 5^2 + 5^1 + 5^0 = 156
        // 3번째 자리: 5^2 + 5^1 + 5^0 = 31
        // 4번째 자리: 5^1 + 5^0 = 6
        // 5번째 자리: 5^0 = 1
        int[] weight = {781, 156, 31, 6, 1};

        // 모음 배열 (사전 순)
        char[] vowels = {'A', 'E', 'I', 'O', 'U'};

        // 단어의 각 글자에 대해 처리
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);

            // 현재 글자가 모음 배열에서 몇 번째 인덱스인지 찾기
            int index = 0;
            for (int j = 0; j < vowels.length; j++) {
                if (vowels[j] == c) {
                    index = j;
                    break;
                }
            }

            // 해당 자리 글자 인덱스에 가중치를 곱해
            // 그 앞에 올 수 있는 단어 개수를 계산
            // +1은 자기 자신을 포함하기 위함
            answer += index * weight[i] + 1;
        }

        // 계산된 위치 반환
        return answer;
    }
}
```

---

## 🔍 예시: "EIO" 위치 구하기

단어 "EIO"가 사전에서 몇 번째에 위치하는지 직접 계산해봅니다.

자리 문자 인덱스 (A=0) 가중치 계산식 누적합
0 E 1 781 1×781 + 1 = 782 782
1 I 2 156 2×156 + 1 = 313 1095
2 O 3 31 3×31 + 1 = 94 1189
✅ 최종 결과: "EIO"는 사전에서 1189번째 단어입니다.

---

## 📦 가중치가 필요한 이유

우리는 단어를 하나씩 다 만들고 세는 대신,

**"이 글자가 오면 몇 개를 건너뛰는지"**를 알고 싶어요.

즉, **'EIO'보다 앞에 있는 단어가 몇 개인가?**를 계산하려는 거예요.

그런데 그걸 매번 DFS로 전부 생성하면 느리니까,

자릿수별로 "이 글자가 올 수 있는 조합 수"를 **미리 계산**해두는 게 바로 **가중치**입니다.

---

## 🎯 가중치의 의미

### 모음 = 5개: A, E, I, O, U

### 단어 최대 길이 = 5

자, 이제 생각해봅시다:

### "A"가 첫 번째 자리에 왔을 때 가능한 모든 조합은?

- A
- AA
- AAA
- AAAA
- AAAAA
- ...
- AAEEU
- AAIOU
- AUUUU
  → A로 시작하는 모든 단어의 개수는?

```
= (1글자 A)      → 1
+ (2글자 AA~AU)  → 5
+ (3글자 AAA~AUU)→ 5^2 = 25
+ (4글자 ...)    → 5^3 = 125
+ (5글자 ...)    → 5^4 = 625

총합 = 1 + 5 + 25 + 125 + 625 = 781

```

### 👉 즉, 첫 글자에 'A'가 들어가면 총 **781개의 단어**를 만들 수 있음

→ 그러므로 누군가 단어의 첫 글자를 'B'로 바꾼다고 하면 (물론 이 문제에선 'A'~'U'만 쓰지만), 그 전에 최소 781개 단어가 있다는 걸 알 수 있어요.

---

## 🧮 전체 가중치 계산 방법

| 자리 | 가중치 계산            | 값  |
| ---- | ---------------------- | --- |
| 1    | 5⁴ + 5³ + 5² + 5¹ + 5⁰ | 781 |
| 2    | 5³ + 5² + 5¹ + 5⁰      | 156 |
| 3    | 5² + 5¹ + 5⁰           | 31  |
| 4    | 5¹ + 5⁰                | 6   |
| 5    | 5⁰                     | 1   |

이걸 통해:

- 첫 자리에서 'A'~'U' 중 몇 번째 문자인지를 곱해서 **그 문자 이전에 있는 단어 수를 한 번에 계산**
- 자리마다 계산해서 누적 → 전체 사전 위치 완성!

---

## 🧠 예시: 단어 "EIO"

- E(1번째 모음) × 자리 1 가중치 781 = 1×781 = 781
- I(2번째 모음) × 자리 2 가중치 156 = 2×156 = 312
- O(3번째 모음) × 자리 3 가중치 31 = 3×31 = 93
- +1 (자기 자신 포함)

→ 총: 781 + 312 + 93 + 1 = **1189번째 단어**

---

## 🔚 결론: 왜 가중치?

- **가중치는 탐색을 수학적으로 빠르게 압축해서 계산하는 도구**입니다.
- 자리마다 가능한 단어의 총 개수를 나타내므로, **순서를 한 번에 계산**할 수 있습니다.
- DFS로 모든 단어를 만들지 않고도 순서를 알 수 있어서 훨씬 빠릅니다.
  (O(L) 시간복잡도, L은 단어 길이 ≤ 5)

---

## ⏱️ 시간 복잡도

문자열 길이는 최대 5이므로 O(1) 수준입니다.

L은 5 이하의 상수이므로 O(1)로 볼 수 있다.

내부 반복도 5번 이내이므로 전체 시간은 매우 작습니다.

---

## ✅ 정리

자릿수에 따라 미리 정의된 가중치 배열을 통해 빠르게 위치를 계산할 수 있습니다.

완전탐색 없이 순위 계산이 가능한 효율적인 문제입니다.

중복 조합 수열의 누적 합을 활용한 인덱싱 기법이 핵심입니다.

---
