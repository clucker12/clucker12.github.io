---
title: "[백준 9935] - 문자열 폭발 - Java 풀이"
date: 2025-08-13
categories: [Baekjoon, Java]
tags: [문자열, 스택, 구현, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 📌 문제 설명

백준 9935번 **"문자열 폭발"** 문제는 주어진 문자열에서 특정 "폭발 문자열"이 등장할 때마다 즉시 삭제하는 과정을 반복하여 최종 문자열을 구하는 문제입니다.  
만약 모든 문자열이 제거되면 `"FRULA"`를 출력해야 합니다.

---

## 💻 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class baekjoon9935 {
    public static void main(String[] args) throws IOException {
        // 입력을 받기 위한 BufferedReader 생성
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 첫 번째 줄: 전체 입력 문자열
        String input = br.readLine();

        // 두 번째 줄: 폭발 문자열
        String boom = br.readLine();

        // 폭발 문자열의 길이 저장
        int boomLen = boom.length();

        // 결과를 저장할 StringBuilder (일종의 스택처럼 사용)
        StringBuilder sb = new StringBuilder();

        // 입력 문자열을 처음부터 끝까지 순회
        for (int i = 0; i < input.length(); i++) {
            // 현재 문자를 결과 문자열에 추가
            sb.append(input.charAt(i));

            // 현재 결과 문자열의 길이가 폭발 문자열 길이 이상이면 폭발 가능성 있음
            if (sb.length() >= boomLen) {
                boolean explode = true; // 폭발 문자열인지 판단하는 플래그

                // 폭발 문자열과 결과 문자열의 끝 부분을 비교
                for (int j = 0; j < boomLen; j++) {
                    // 현재 결과 문자열의 끝에서 boom 문자열과 다르면 폭발 아님
                    if (sb.charAt(sb.length() - boomLen + j) != boom.charAt(j)) {
                        explode = false; // 폭발 문자열 아님
                        break; // 비교 중단
                    }
                }

                // 폭발 문자열이 일치하면 삭제
                if (explode) {
                    // 폭발 문자열 길이만큼 삭제 (문자열 폭발)
                    sb.delete(sb.length() - boomLen, sb.length());
                }
            }
        }

        // 모든 폭발이 끝난 후 문자열이 비었으면 "FRULA" 출력
        if (sb.length() == 0) {
            System.out.println("FRULA");
        } else {
            // 아니면 남은 문자열 출력
            System.out.println(sb.toString());
        }
    }
}

```

---

## 🛠 풀이 접근 방법

1. **문자열을 순차적으로 읽으며 StringBuilder에 저장**
2. **StringBuilder의 끝부분이 폭발 문자열과 일치하는지 검사**
3. **일치하면 즉시 삭제 → 마치 '스택'처럼 동작**
4. **모든 탐색이 끝난 후 결과 출력**
   - 비어 있으면 `"FRULA"` 출력

---

## 📊 시간 복잡도

- **O(N × M)**
  - N: 입력 문자열 길이
  - M: 폭발 문자열 길이
  - 최악의 경우 매번 끝부분 비교를 수행하므로 이 복잡도가 나옵니다.

---

## 📚 주요 메서드 및 핵심 로직

- **`StringBuilder`**
  - 가변적인 문자열 처리에 유리
  - `append()` → 문자열 뒤에 추가
  - `delete(start, end)` → 특정 구간 삭제
- **스택처럼 동작**
  - 최근에 추가된 문자들이 폭발 문자열과 비교됨
  - 불필요한 문자열 이동 없이 효율적 삭제 가능

---

## 📦 사용한 자료구조

- **StringBuilder**
  - 문자열 변경이 잦을 때 성능상 이점
  - `charAt()`, `delete()`를 통한 빠른 조작 가능

---

## 💡 마무리

이 문제를 풀면서 느낀 점은,

- 문자열 처리 문제에서도 **스택 사고방식**이 매우 유용하다는 점입니다.
- 단순 문자열 더하기/빼기를 반복하는 대신, **StringBuilder**를 스택처럼 사용하면 시간 효율이 크게 개선됩니다.
- '최근에 추가된 문자'만 비교하면 되기 때문에, 불필요한 연산을 줄일 수 있습니다.

---

## 📝 느낀점

처음에는 `replace()` 메서드를 떠올렸지만, 이는 매번 문자열을 새로 생성하여 비효율적이었습니다.  
이번 문제는 **'마지막에 추가된 문자부터 확인'**하는 **스택적 접근**을 배워갈 수 있었던 좋은 연습이었습니다.  
또한, StringBuilder의 `delete()`와 `append()`를 함께 사용하면 효율적인 문자열 조작이 가능하다는 점을 다시 느꼈습니다.
