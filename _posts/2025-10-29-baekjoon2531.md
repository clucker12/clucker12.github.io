---
title: "[백준 2531번] 회전 초밥 🍣 (Sliding Window) - Java"
date: 2025-10-29
categories: [Baekjoon, Java, SlidingWindow]
tags: [백준, 슬라이딩윈도우, 투포인터, 구현, Java]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 📘 문제 설명

회전 초밥 벨트 위에서 연속된 `k`개의 접시를 먹을 때, **서로 다른 초밥 종류의 최대 개수**를 구하는 문제입니다.  
단, 쿠폰을 사용하면 특정 초밥 종류(`c`)를 **추가로 무료로 먹을 수 있습니다.**

---

## 🧩 접근 방법

이 문제는 **슬라이딩 윈도우(Sliding Window)** 기법을 이용한 구현 문제입니다.

1. 초기에 `k`개의 접시를 선택하고, 각 초밥 종류의 개수를 카운트합니다.
2. 이후 한 칸씩 윈도우를 옮기며, 맨 앞 초밥을 제거하고 새로운 초밥을 추가합니다.
3. 매 이동마다 쿠폰 초밥(`c`)이 포함되어 있는지 검사하여 최댓값을 갱신합니다.
4. 회전 초밥이므로 `(i + k) % N`으로 인덱스를 순환시킵니다.

---

## 💻 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon2531 {
    // N: 접시 수, d: 초밥 종류 수, k: 연속해서 먹는 접시 수, c: 쿠폰 초밥 번호
    static int N, d, k, c;
    static int[] food;   // 회전 초밥 벨트 위의 초밥들
    static int[] count;  // 각 초밥 종류별 현재 윈도우 내 등장 횟수

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 입력 1줄: N, d, k, c
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());  // 접시 수
        d = Integer.parseInt(st.nextToken());  // 초밥 종류 수
        k = Integer.parseInt(st.nextToken());  // 연속으로 먹을 접시 수
        c = Integer.parseInt(st.nextToken());  // 쿠폰 초밥 번호

        // 회전 초밥 벨트 위의 초밥 정보를 입력받음
        food = new int[N];
        for (int i = 0; i < N; i++) {
            food[i] = Integer.parseInt(br.readLine());
        }

        // 각 초밥 종류별 현재 윈도우 내 초밥 개수를 저장하는 배열
        count = new int[d + 1]; // 초밥 번호가 1~d이므로 d+1 크기
        int distinct = 0;       // 현재 윈도우(연속 구간)에서의 서로 다른 초밥 수

        // ✅ 초기 윈도우 설정 (처음 k개의 접시)
        for (int i = 0; i < k; i++) {
            if (count[food[i]] == 0) distinct++; // 처음 등장하는 초밥이면 종류 +1
            count[food[i]]++;                    // 해당 초밥 카운트 증가
        }

        int max = distinct; // 현재까지의 최대 초밥 종류 수 저장

        // ✅ 슬라이딩 윈도우 시작 (회전벨트이므로 N번 반복)
        for (int i = 0; i < N; i++) {
            // 윈도우의 맨 앞 초밥 제거
            int remove = food[i];
            count[remove]--;
            if (count[remove] == 0) distinct--; // 초밥 종류가 0이 되면 종류 수 감소

            // 윈도우의 맨 뒤 초밥 추가 (회전하므로 인덱스 % N)
            int add = food[(i + k) % N];
            if (count[add] == 0) distinct++; // 새로운 종류의 초밥이면 +1
            count[add]++;

            // 현재 윈도우에서 먹을 수 있는 초밥 종류 수 계산
            int currentMax = distinct;

            // 쿠폰 초밥이 현재 윈도우에 포함되지 않은 경우, +1종류 추가 가능
            if (count[c] == 0) currentMax++;

            // 최대값 갱신
            if (currentMax > max) max = currentMax;
        }

        // ✅ 결과 출력: 먹을 수 있는 서로 다른 초밥의 최대 종류 수
        System.out.println(max);
    }
}

```

---

## ⚙️ 핵심 로직 정리

| 구분                | 설명                                          |
| ------------------- | --------------------------------------------- |
| **슬라이딩 윈도우** | 연속된 `k`개의 접시를 유지하며 한 칸씩 이동   |
| **쿠폰 초밥 처리**  | 현재 윈도우에 쿠폰 초밥이 없으면 +1 종류 추가 |
| **회전 처리**       | `(i + k) % N`을 사용하여 원형 처리            |
| **최대값 갱신**     | `max = Math.max(max, currentMax)`             |

---

## 💾 사용된 자료구조

| 자료구조      | 설명                                    |
| ------------- | --------------------------------------- |
| `int[] food`  | 회전 초밥 벨트에 놓인 초밥 번호 저장    |
| `int[] count` | 각 초밥 종류별 현재 윈도우 내 등장 횟수 |
| `int`         | 최대 종류 수, 현재 종류 수 등 계산용    |

---

## 🧮 시간 복잡도 분석

- 초기 윈도우 설정: `O(k)`
- 슬라이딩 윈도우 이동: `O(N)`
- **전체 시간 복잡도:** `O(N)`
- N ≤ 3,000,000 이므로 충분히 효율적입니다.

---

## 🧠 주요 메서드 설명

| 메서드 / 로직                 | 설명                                      |
| ----------------------------- | ----------------------------------------- |
| `for (int i = 0; i < k; i++)` | 초기 윈도우 설정 (k개의 초밥 종류 카운트) |
| `for (int i = 0; i < N; i++)` | 슬라이딩 윈도우 순회                      |
| `count[remove]--`             | 맨 앞 초밥 제거 시 카운트 감소            |
| `count[add]++`                | 새 초밥 추가 시 카운트 증가               |
| `if (count[c] == 0)`          | 쿠폰 초밥 미포함 시 +1                    |

---

## 🧱 핵심 코드 설명

```java
// ✅ 초기 윈도우 설정
for (int i = 0; i < k; i++) {
    if (count[food[i]] == 0) distinct++;
    count[food[i]]++;
}

// ✅ 슬라이딩 윈도우 순회
for (int i = 0; i < N; i++) {
    int remove = food[i]; // 맨 앞 초밥 제거
    count[remove]--;
    if (count[remove] == 0) distinct--;

    int add = food[(i + k) % N]; // 새로운 초밥 추가 (회전 처리)
    if (count[add] == 0) distinct++;
    count[add]++;

    int currentMax = distinct;
    if (count[c] == 0) currentMax++; // 쿠폰 초밥 추가 고려

    max = Math.max(max, currentMax);
}
```

---

## 💡 느낀점

이 문제는 단순 구현 문제 같지만, **"슬라이딩 윈도우 + 원형 구조"**의 조합이라는 점에서 흥미로웠습니다.  
특히 쿠폰 초밥의 처리와 `(i + k) % N`을 이용한 회전 처리 부분이 핵심 포인트입니다.

이 문제를 통해 **투포인터 기법과 슬라이딩 윈도우의 실전 활용**을 더 깊게 이해할 수 있었고,  
**중복 카운팅 관리(count 배열)**의 중요성을 다시금 깨달았습니다.
