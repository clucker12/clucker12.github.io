---
title: "[백준 3085] 사탕 게임 문제 풀이 - Java"
date: 2025-10-09
categories: [Baekjoon, Java]
tags: [브루트포스, 구현, 사탕게임, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 🍬 [백준 3085] 사탕 게임

---

## 📘 문제 설명

NxN 크기의 보드에 여러 색의 사탕이 놓여 있습니다.  
인접한 두 칸의 사탕을 교환했을 때, 같은 색의 사탕이 가장 많이 연속으로 놓이는 경우의 최대 길이를 구하는 문제입니다.

---

## 💡 접근 방법

1. **완전 탐색(Brute Force)** 접근

   - 모든 칸을 순회하면서, 오른쪽 또는 아래쪽의 사탕과 교환을 시도합니다.
   - 교환 후 `checkMaxCandy()` 함수를 통해 현재 보드 상태에서 가장 긴 같은 색의 연속 길이를 계산합니다.
   - 교환 후 다시 원상복구하여 다른 경우를 시도합니다.

2. **핵심 아이디어**
   - 한 번의 교환으로만 최대 연속 길이를 계산해야 하므로, **모든 가능한 교환**을 시도해야 합니다.
   - 각 교환마다 보드를 완전히 검사하므로 **시간 복잡도는 O(N³)** 입니다.

---

## 💻 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class baekjoon3085 {
    // 보드 크기 N
    static int N;

    // 사탕 색상 보드를 저장할 2차원 배열
    static char[][] candy;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // N 입력 받기
        N = Integer.parseInt(br.readLine());

        // 사탕 보드 배열 초기화
        candy = new char[N][N];

        // 보드 정보 입력 받기 (각 행마다 한 줄씩)
        for (int i = 0; i < N; i++) {
            String line = br.readLine(); // 한 줄 입력
            for (int j = 0; j < N; j++) {
                candy[i][j] = line.charAt(j); // 문자 하나씩 배열에 저장
            }
        }

        int result = 0; // 최대 사탕 개수 결과 저장 변수

        // 보드의 모든 칸을 순회
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {

                // 오른쪽 칸과 교환
                if (j + 1 < N) {
                    // 사탕 색이 다른 경우만 교환 (❗주의: 이 조건은 없어도 됨. 문제 설명 참조)
                    if (candy[i][j] != candy[i][j + 1]) {
                        swap(i, j, i, j + 1); // 교환
                        result = Math.max(result, checkMaxCandy()); // 최대 길이 계산
                        swap(i, j, i, j + 1); // 원상복구
                    }
                }

                // 아래쪽 칸과 교환
                if (i + 1 < N) {
                    if (candy[i][j] != candy[i + 1][j]) {
                        swap(i, j, i + 1, j);
                        result = Math.max(result, checkMaxCandy());
                        swap(i, j, i + 1, j);
                    }
                }
            }
        }

        // 정답 출력
        System.out.println(result);
    }

    // 두 칸의 사탕을 교환하는 함수
    static void swap(int x1, int y1, int x2, int y2) {
        char temp = candy[x1][y1];
        candy[x1][y1] = candy[x2][y2];
        candy[x2][y2] = temp;
    }

    // 현재 보드 상태에서 가장 긴 연속된 사탕 개수를 계산하는 함수
    static int checkMaxCandy() {
        int max = 1; // 최대 사탕 길이 (최소는 1)

        // 각 행과 열을 검사
        for (int i = 0; i < N; i++) {
            int rowcnt = 1; // 행 연속 카운트
            int colcnt = 1; // 열 연속 카운트

            for (int j = 1; j < N; j++) {
                // 같은 행에서 왼쪽 사탕과 같은 색인지 확인
                if (candy[i][j] == candy[i][j - 1]) {
                    rowcnt++; // 연속 증가
                } else {
                    rowcnt = 1; // 연속 끊김 → 1로 초기화
                }
                max = Math.max(max, rowcnt); // 최대값 갱신

                // 같은 열에서 위쪽 사탕과 같은 색인지 확인
                if (candy[j][i] == candy[j - 1][i]) {
                    colcnt++;
                } else {
                    colcnt = 1;
                }
                max = Math.max(max, colcnt); // 최대값 갱신
            }
        }

        return max;
    }
}

```

---

## 🔍 주요 메서드 설명

| 메서드            | 역할                                            |
| ----------------- | ----------------------------------------------- |
| `swap()`          | 두 칸의 사탕을 교환하는 함수                    |
| `checkMaxCandy()` | 현재 보드에서 가장 긴 연속된 사탕의 개수를 계산 |
| `main()`          | 전체 로직을 제어하며 모든 경우를 탐색           |

---

## 🧩 핵심 로직

1. `swap()`을 통해 인접한 두 칸의 사탕을 교환
2. `checkMaxCandy()`로 행과 열의 연속된 사탕 개수 계산
3. 최대값을 갱신 후, 다시 원상 복구하여 다음 탐색 진행

---

## 🧠 사용한 자료구조

- `char[][] candy` : 보드 정보를 저장하는 2차원 배열
- 단순한 배열 기반 완전 탐색이므로, 추가적인 자료구조는 사용하지 않음

---

## ⏱️ 시간 복잡도

- 모든 칸 탐색: **O(N²)**
- 각 교환마다 보드 검사: **O(N²)**
- **총 시간 복잡도:** `O(N³)`

---

## 💬 느낀 점

이 문제는 브루트포스(완전탐색)의 전형적인 형태로,  
모든 가능한 상태를 직접 탐색해봐야 답을 구할 수 있습니다.

단순하지만 효율적인 사고가 필요했으며,  
교환 후 상태를 정확히 복구하는 과정에서 **시뮬레이션 구현 능력**이 중요했습니다.

특히 `checkMaxCandy()` 구현 시 행과 열을 각각 검사해야 하는 점이 헷갈릴 수 있었지만,  
코드를 구조적으로 정리하면서 문제의 본질을 명확히 이해할 수 있었습니다.

---
