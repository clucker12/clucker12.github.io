---
title: "[백준 2304번] 창고 다각형 🏠"
date: 2025-11-03
categories: [Baekjoon, Implementation, Simulation]
tags: [백준, 구현, 시뮬레이션, 자료구조, 스택, 그리디]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 📘 문제 개요

> **문제 번호:** 2304  
> **문제 이름:** 창고 다각형  
> **난이도:** 실버 1  
> **문제 링크:** [https://www.acmicpc.net/problem/2304](https://www.acmicpc.net/problem/2304)

---

## 🧩 문제 설명

기둥 N개의 위치(x좌표)와 높이가 주어진다.  
이 기둥들을 왼쪽에서 오른쪽으로 잇고,  
맨 왼쪽과 맨 오른쪽을 연결했을 때 생기는 **다각형의 면적**을 구하는 문제이다.

---

## 💡 접근 방법

1. **입력받은 기둥을 x좌표 기준으로 정렬**
2. **가장 높은 기둥(최고점) 찾기**
3. **왼쪽 → 최고점까지 면적 누적**
4. **오른쪽 → 최고점까지 면적 누적**
5. **최고 기둥 면적(1칸) 추가**

---

## 💻 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class baekjoon2304 {
    static int N;           // 기둥 개수
    static int[][] arr;     // 각 기둥의 (x좌표, 높이)

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // ✅ 1. 입력받기
        N = Integer.parseInt(br.readLine());
        arr = new int[N][2];
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            arr[i][0] = Integer.parseInt(st.nextToken()); // x좌표
            arr[i][1] = Integer.parseInt(st.nextToken()); // 높이
        }

        // ✅ 2. x좌표 기준 오름차순 정렬
        //    (기둥이 랜덤 순서로 들어오므로, 왼쪽→오른쪽 순서로 정렬 필요)
        Arrays.sort(arr, Comparator.comparingInt(a -> a[0]));

        // ✅ 3. 가장 높은 기둥(지붕의 최고점) 찾기
        int maxH = 0;       // 최고 높이
        int maxIdx = 0;     // 최고 높이를 가진 기둥의 인덱스
        for (int i = 0; i < N; i++) {
            if(arr[i][1] > maxH){
                maxH = arr[i][1];
                maxIdx = i;
            }
        }

        int area = 0; // 전체 면적 누적 변수

        // ✅ 4. 왼쪽 → 최고 기둥까지 면적 계산
        //   왼쪽에서 오른쪽으로 진행하면서,
        //   현재까지의 '가장 높은 높이'를 유지하며 면적을 더함.
        int leftMax = arr[0][1];  // 현재까지 본 왼쪽 최고 높이
        int leftX = arr[0][0];    // 최고 높이의 x좌표
        for (int i = 1; i <= maxIdx; i++) {
            // 만약 현재 기둥이 지금까지의 최고 높이 이상이라면
            if (arr[i][1] >= leftMax) {
                // 직사각형 면적 = (x거리) × (현재 최고 높이)
                area += (arr[i][0] - leftX) * leftMax;

                // 최고 높이 및 기준 x 갱신
                leftMax = arr[i][1];
                leftX = arr[i][0];
            }
        }

        // ✅ 5. 오른쪽 → 최고 기둥까지 면적 계산
        //   오른쪽 끝에서 왼쪽으로 진행하면서,
        //   현재까지의 '가장 높은 높이'를 유지하며 면적을 더함.
        int rightMax = arr[N - 1][1]; // 현재까지 본 오른쪽 최고 높이
        int rightX = arr[N - 1][0];   // 최고 높이의 x좌표
        for (int i = N - 2; i >= maxIdx; i--) {
            // 현재 기둥이 지금까지의 최고 높이 이상이면
            if (arr[i][1] >= rightMax) {
                // 직사각형 면적 = (x거리) × (현재 최고 높이)
                area += (rightX - arr[i][0]) * rightMax;

                // 최고 높이 및 기준 x 갱신
                rightMax = arr[i][1];
                rightX = arr[i][0];
            }
        }

        // ✅ 6. 가장 높은 기둥(최고점) 한 칸 면적 추가
        //    왼쪽/오른쪽 스캔에서는 최고 기둥 자체는 계산되지 않았기 때문
        area += maxH;

        // ✅ 7. 결과 출력
        System.out.println(area);
    }
}
```

---

## 🔍 핵심 로직 요약

| 단계           | 핵심 아이디어 | 설명                                |
| -------------- | ------------- | ----------------------------------- |
| 1️⃣ 정렬        | Arrays.sort() | x좌표 오름차순 정렬                 |
| 2️⃣ 최고점 탐색 | 반복문        | 최대 높이와 인덱스 찾기             |
| 3️⃣ 왼쪽 스캔   | 왼→오 방향    | 누적 현재까지 최고 높이로 면적 계산 |
| 4️⃣ 오른쪽 스캔 | 오→왼 방향    | 누적 반대 방향으로 동일하게 계산    |
| 5️⃣ 최고점 추가 | area += maxH  | 최고 기둥 한 칸 추가                |

---

## ⚙️ 시간 복잡도

| 연산   | 복잡도     | 설명          |
| ------ | ---------- | ------------- |
| 정렬   | O(N log N) | Arrays.sort() |
| 왼쪽   | 스캔 O(N)  | 한 번 순회    |
| 오른쪽 | 스캔 O(N)  | 한 번 순회    |
| 전체   | O(N log N) | 정렬이 지배적 |

---

## 🧱 사용된 자료구조

- 2차원 배열 int[][] arr → (x좌표, 높이)
- 단순 변수 계산 방식 → 스택이나 리스트 없이 구현 가능
- 정렬 후 인덱스 순회 → O(N log N) 최적 효율

---

## 💭 느낀점

이 문제는 복잡한 알고리즘보다는
그리디한 방향 스캔과 구현력이 핵심이었다.

초기엔 “다각형 면적”이라는 단어 때문에 기하학적으로 접근했지만,
실제로는 “막대그래프 형태의 단순 면적 합” 문제였다.

특히, 왼쪽/오른쪽으로 각각 스캔하면서 현재까지의 최고 높이를 유지하는 방식은
다른 그래프 누적 문제에서도 자주 쓰이는 패턴이었다.

이번 문제를 통해 느낀 점은:

- 정렬 + 양방향 스캔으로 효율적인 면적 계산이 가능하다.
- 탐색 방향을 나누는 사고(왼쪽/오른쪽) 가 구현 문제를 단순화한다.
- 시뮬레이션 문제일수록 직관적인 로직 구조화가 중요하다. 💡
