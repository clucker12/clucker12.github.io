---
title: "C언어 포인터와 malloc으로 2차원 배열 다루기 완벽 정리"
categories: [정보처리기사, C언어]
tags: [C언어, 포인터, malloc, 2차원 배열, 동적할당]
toc: true
date: 2025-06-27 10:00:00 +0900
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
sidebar:
  nav: "counts"
---

# C언어 포인터와 malloc으로 2차원 배열 다루기 완벽 정리

이번 글에서는 C언어에서 `malloc`과 포인터를 활용해  
**2차원 배열을 동적 할당**하는 방법과,  
`int (*in)[N]` 같은 복잡한 포인터 선언이 의미하는 바를 쉽게 풀어보겠습니다.

---

## 1. 문제 상황과 코드 예시

```c
#define N 3

int main(void) {
    int (*in)[N];
    in = (int(*)[N])malloc(N * N * sizeof(int));
    // 이후 in[i][j]처럼 2차원 배열처럼 사용 가능
}
```

여기서 in은 포인터인데,
int (\*in)[N]가 무슨 뜻인지,
malloc이 2차원 배열을 어떻게 만들어주는지 궁금할 수 있습니다.

## 2. 포인터 선언: int (\*in)[N] 뜻

- \*in은 in이 포인터임을 나타냅니다.
- [N]은 in이 가리키는 대상이 int형 배열 N개임을 나타냅니다.
- 따라서 in은 <br>
  "int N개짜리 배열을 가리키는 포인터" 입니다.

# 비유

- int \*p는 "int 하나를 가리키는 포인터"
- int (\*p)[3]는 "int 3개짜리 배열 하나를 가리키는 포인터"
- 배열 하나가 포인터가 가리키는 단위가 된다는 뜻입니다.

## 3. malloc은 메모리를 어떻게 할당하는가?

```
malloc(N * N * sizeof(int))
```

- 9개의 int 크기만큼 연속된 메모리 공간을 할당합니다.
- 이 메모리는 본질적으로 1차원 배열과 같습니다.
- 아무런 구조 정보가 없고, 그냥 바이트가 쭉 이어진 덩어리입니다.

## 4. 그럼 어떻게 2차원 배열이 되는가?

```
in = (int(*)[N])malloc(N * N * sizeof(int));
```

- 여기서 malloc이 준 연속 공간을
- int (\*)[N] 타입으로 캐스팅(해석) 합니다.

# 이 캐스팅의 의미

- "이 연속된 메모리를 N개짜리 배열의 배열로 보겠다"는 뜻입니다.
- 그래서 우리는 in[i][j] 형태로 접근할 수 있습니다.

## 5. 메모리 구조 시각화

| 메모리 주소 | 데이터 (int 값) |
| ----------- | --------------- |
| &in[0][0]   | 0               |
| &in[0][1]   | 1               |
| &in[0][2]   | 2               |
| &in[1][0]   | 3               |
| &in[1][1]   | 4               |
| &in[1][2]   | 5               |
| &in[2][0]   | 6               |
| &in[2][1]   | 7               |
| &in[2][2]   | 8               |

- in은 주소를 한 칸씩 3개 묶음 단위로 끊어 보는 포인터입니다.
- 그래서 2차원 배열처럼 보입니다.

## 6. int *in[N] 와 int (*in)[N] 차이

| 선언           | 의미                                 |
| -------------- | ------------------------------------ |
| int \*in[N];   | int형 포인터가 N개 모인 배열         |
| int (\*in)[N]; | int형 N개짜리 배열을 가리키는 포인터 |

## 7. 자세한 예시와 그림으로 이해하기

# 7-1. int \*in[N]; - 포인터 배열

- in은 포인터가 N개 있는 배열입니다.
- 각 in[i]는 int\* 타입으로, 서로 다른 메모리 주소를 가리킬 수 있습니다.

```
int a = 10, b = 20, c = 30;
int *in[3];

in[0] = &a;
in[1] = &b;
in[2] = &c;

// 접근
printf("%d %d %d\n", *in[0], *in[1], *in[2]);
```

- 메모리 모습:

```
in (배열)  ──────────▶ ┌────┐    ┌────┐    ┌────┐
                       │ &a │    │ &b │    │ &c │
                       └────┘    └────┘    └────┘
                         |         |         |
                        10        20        30
```

- 각 포인터가 각각 다른 변수(주소)를 가리키므로
- 메모리가 연속적이지 않아도 되고, 자유롭게 연결할 수 있습니다.

# 7-2. int (\*in)[N]; - 배열 포인터

- in은 int 배열 N개짜리 배열을 가리키는 포인터입니다.
- 즉, 한 번에 N개가 연속된 int 배열을 가리킵니다.

```int (*in)[3];
in = malloc(sizeof(int[3]) * 3); // 3x3 int 배열

// 값 넣기
for (int i=0; i<3; i++)
    for (int j=0; j<3; j++)
        in[i][j] = i*3 + j;
```

- 메모리 모습:

```
in ──────────▶ ┌────┬────┬────┐
               │ 0  │ 1  │ 2  │  → in[0][*]
               ├────┼────┼────┤
               │ 3  │ 4  │ 5  │  → in[1][*]
               ├────┼────┼────┤
               │ 6  │ 7  │ 8  │  → in[2][*]
               └────┴────┴────┘
```

- 한 덩어리로 연속된 메모리를 묶어
- 2차원 배열처럼 다룰 수 있습니다.

# 7-3. 요약 비교표

| 구분             | int \*in[N] (포인터 배열)                          | int (\*in)[N] (배열 포인터)        |
| ---------------- | -------------------------------------------------- | ---------------------------------- |
| 선언 의미        | 포인터가 N개 들어있는 배열                         | N개짜리 int 배열을 가리키는 포인터 |
| 메모리 구조      | 포인터 배열은 연속, 가리키는 대상은 분산 가능      | 연속된 2차원 배열 메모리           |
| 메모리 할당 방식 | 각 포인터가 각각 메모리를 가리킴                   | 한 번에 큰 연속 메모리를 할당      |
| 접근 방식        | \*in[i]                                            | in[i][j]                           |
| 장점             | 유연성 (각 포인터가 다른 크기 배열 가리킬 수 있음) | 캐시 효율 좋고, 간단한 메모리 관리 |
| 단점             | 메모리가 연속적이지 않아 효율 떨어질 수 있음       | 메모리 크기 고정, 크기 변경 불편   |

## 8. malloc은 메모리를 어떻게 할당하는가?

```
malloc(N * N * sizeof(int))
```

- 9개의 int 크기만큼 연속된 메모리 공간을 할당합니다.
- 이 메모리는 본질적으로 1차원 배열과 같습니다.
- 아무런 구조 정보가 없고, 그냥 바이트가 쭉 이어진 덩어리입니다.

## 9. malloc과 포인터 타입의 관계

| 개념            | 설명                                       |
| --------------- | ------------------------------------------ |
| malloc          | 메모리 크기만 확보, 구조 없음              |
| int(\*)[N] 타입 | 확보된 메모리를 “N개짜리 배열” 단위로 해석 |
| 결과            | 2차원 배열처럼 in[i][j]로 접근 가능        |

## 10. 실제 동작 코드 예제

```
#include <stdio.h>
#include <stdlib.h>

#define N 3

int main(void) {
    int (*in)[N];
    int i, j;

    in = (int(*)[N])malloc(N * N * sizeof(int));
    if (!in) {
        perror("malloc failed");
        return 1;
    }

    // 값 넣기
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            in[i][j] = i * N + j;
        }
    }

    // 출력
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            printf("%d ", in[i][j]);
        }
        printf("\n");
    }

    free(in);
    return 0;
}
```

## 11. 마무리

- int \*in[N]는 포인터 배열로 각각 다른 메모리를 가리키고,
- int (\*in)[N]는 배열 포인터로 한 번에 연속된 2차원 배열 메모리를 가리킵니다.
- malloc은 메모리 공간만 할당하며,
- 포인터 타입으로 해석 방식을 정해줍니다.

## 12. FAQ

Q1: int **in과 어떻게 다른가요? <br>
int **in은 포인터를 가리키는 포인터로, 2차원 배열을 표현하는 다른 방법입니다.<br>
그러나 int \*\*in은 메모리 연속성을 보장하지 않고, 다중 할당이 필요합니다.<br>

Q2: 왜 int (\*in)[N]를 쓰나요?<br>
연속된 메모리 공간을 사용해 캐시 효율을 높이고, 메모리 관리를 쉽게 하기 위해서입니다.<br>

## 13. 참고자료

- C언어 포인터 개념 정리
- malloc과 동적할당 이해하기
