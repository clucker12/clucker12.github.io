---
title: "[백준 6064] 카잉 달력 문제 풀이 - Java"
date: 2025-09-26
categories: [Baekjoon, Java]
tags: [수학, 정수론, 최소공배수, 브루트포스, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 📝 문제 설명

카잉 달력은 <M, N> 주기를 갖는 달력으로,  
해마다 x와 y 값이 각각 1씩 증가하다가 M과 N에 도달하면 1로 돌아갑니다.  
주어진 M, N, x, y가 있을 때 **<x, y>가 몇 번째 해**인지 구하는 문제입니다.

---

## 💡 접근 방법

1. **수학적 성질 이용**
   - 최대 연도는 `lcm(M, N)` (최소공배수) 이하입니다.
   - x를 기준으로 연도를 증가시키며 y 조건을 만족하는지 확인합니다.
2. **0-based 변환**
   - 계산 편의를 위해 (x-1), (y-1)로 변환 후 작업 후, 결과는 다시 +1.

---

## ⏱️ 시간 복잡도

- 최악의 경우 O(lcm(M, N) / M) = O(N) (대략 M과 N 중 큰 값에 비례).
- M, N ≤ 40,000 이므로 충분히 통과.

---

## 🔑 주요 메서드 & 자료구조

- gcd / lcm: 유클리드 호제법을 통한 최대공약수 및 최소공배수 계산.
- findYear: 문제 해결의 핵심. x를 기준으로 step(M)씩 증가.
- 자료구조: 단순한 정수 연산만 사용 → 별도 자료구조 불필요.

---

## ✅ 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon6064 {
    static int T, M, N, x, y;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // 입력을 빠르게 받기 위한 BufferedReader
        StringTokenizer st;

        int T = Integer.parseInt(br.readLine()); // 테스트 케이스 수 입력
        for (int i = 0; i < T; i++) {
            // 테스트 케이스별 입력 파싱
            st = new StringTokenizer(br.readLine());
            int M = Integer.parseInt(st.nextToken()); // M년 주기 (x의 최대값)
            int N = Integer.parseInt(st.nextToken()); // N년 주기 (y의 최대값)
            int x = Integer.parseInt(st.nextToken()); // x년 (1-based)
            int y = Integer.parseInt(st.nextToken()); // y년 (1-based)

            // 결과 출력 (x, y는 내부 계산 편의를 위해 0-based로 변환)
            System.out.println(findYear(M, N, x - 1, y - 1));
        }
    }

    // 최대공약수(GCD) 구하는 함수 - 유클리드 호제법 사용
    static int gcd(int a, int b) {
        while (b != 0) {
            int tmp = a % b;
            a = b;
            b = tmp;
        }
        return a;
    }

    // 최소공배수(LCM) 구하는 함수
    static int lcm(int a, int b) {
        return a * b / gcd(a, b);
    }

    // <x, y>가 몇 번째 해인지 찾는 함수
    static int findYear(int M, int N, int x, int y) {
        // 카잉 달력의 최대 연도는 M과 N의 최소공배수
        int maxYear = lcm(M, N);

        // x값을 기준으로 year = x + M * i 형태로 증가
        // 해당 year가 y 조건도 만족하는지 확인
        for (int i = 0; x + M * i < maxYear; i++) {
            int year = x + M * i; // 현재 검사할 연도

            // y값은 (year % N)이어야 함 (0-based로 계산 중)
            if (year % N == y) {
                return year + 1; // 실제 연도는 1-based이므로 +1
            }
        }

        // 조건을 만족하는 해가 없으면 -1 반환
        return -1;
    }
}

```

---

## 🧩 핵심 코드

```java
// 최대공약수
static int gcd(int a, int b) {
    while (b != 0) {
        int tmp = a % b;
        a = b;
        b = tmp;
    }
    return a;
}

// 최소공배수
static int lcm(int a, int b) {
    return a * b / gcd(a, b);
}

// <x, y>가 몇 번째 해인지 찾는 함수
static int findYear(int M, int N, int x, int y) {
    int maxYear = lcm(M, N);
    for (int i = 0; x + M * i < maxYear; i++) {
        int year = x + M * i;
        if (year % N == y) return year + 1; // 1-based 복원
    }
    return -1;
}
```

- year = x + M \* i 형태로 증가시키며 year % N == y인지 확인.

- 최대 탐색 범위는 lcm(M, N)까지이므로 유한.

---

## 🏁 마무리 & 느낀 점

단순한 브루트포스는 범위가 커지면 비효율적이지만,
이 문제는 **수학적 성질(최소공배수, 유클리드 호제법)**을 활용하면
탐색 범위를 획기적으로 줄일 수 있음을 깨달았습니다.
문제를 수학적으로 재해석하는 접근이 알고리즘을 크게 단순화할 수 있음을 다시 느꼈습니다.
