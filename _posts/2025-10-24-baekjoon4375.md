---
title: "[백준 4375] 1로만 이루어진 배수 찾기 - Java"
date: 2025-10-24
categories: [Baekjoon, Java]
tags: [수학, 나머지연산, 브루트포스, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 📘 문제 설명

자연수 n이 주어졌을 때, **1로만 이루어진 n의 배수 중 가장 작은 수의 자릿수**를 구하는 문제입니다.  
단, n은 2나 5의 배수가 아닙니다.

---

## 💻 코드

```java
package Baekjoon;

import java.util.Scanner;

public class baekjoon4375 {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in); // 표준 입력을 받기 위한 Scanner 생성

        // 입력이 여러 줄로 들어오기 때문에
        // hasNextInt()로 입력이 더 이상 없을 때까지 반복
        while (sc.hasNextInt()){
            int n = sc.nextInt(); // n 입력받기 (2나 5로 나누어지지 않는 수)

            int cnt = 1;     // 자릿수 (맨 처음 1로 시작하므로 1자리)
            int num = 1 % n; // 현재 '1'로만 이루어진 수를 n으로 나눈 나머지 저장 (처음엔 1)

            // num이 0이 될 때까지 반복
            // num == 0 이라는 건, 지금까지 만든 '1...1'이 n의 배수라는 뜻
            while(num != 0){
                // 다음 자리에 '1'을 추가한 수의 나머지를 구함
                // 예: num=1 → (1*10+1)=11 → 11%n 의 나머지 계산
                num = (num * 10 + 1) % n;

                // 한 자리 추가됐으므로 자릿수 증가
                cnt++;
            }

            // num % n == 0 이 되는 순간의 cnt 출력
            // 즉, 모든 자릿수가 1로만 이루어진 n의 배수 중 가장 작은 수의 자릿수
            System.out.println(cnt);
        }

        sc.close(); // Scanner 자원 해제
    }
}
```

---

## ⚙️ 핵심 로직 정리

| 구분             | 설명                                                            |
| ---------------- | --------------------------------------------------------------- |
| 나머지 연산 활용 | 실제 큰 수를 만들지 않고 `(num * 10 + 1) % n`으로 나머지만 계산 |
| 반복 조건        | 나머지가 0이 될 때까지 반복                                     |
| 자릿수 계산      | 매 반복마다 1의 개수를 증가시켜 최소 자릿수 찾기                |
| 입력 처리        | 여러 개의 n에 대해 반복적으로 처리 (`while (hasNextInt())`)     |

---

## 🧩 주요 메서드 설명

| 메서드명               | 설명                                      |
| ---------------------- | ----------------------------------------- |
| `hasNextInt()`         | 입력 스트림에 다음 정수가 존재하는지 확인 |
| `nextInt()`            | 정수 입력 받기                            |
| `System.out.println()` | 결과(자릿수) 출력                         |

---

## 💾 사용된 자료구조

| 자료구조  | 설명                          |
| --------- | ----------------------------- |
| `int`     | 나머지 계산과 자릿수 카운팅용 |
| `Scanner` | 입력을 처리하기 위한 클래스   |

---

## ⏱️ 시간 복잡도 분석

- 각 테스트 케이스마다 최대 **O(n)** 반복  
  (나머지가 0이 될 때까지 반복하며, 최악의 경우 n번 반복)

- 전체 시간 복잡도: **O(T × n)**  
  (T는 입력된 테스트 케이스 수)

---

## 💡 구현 시 주의할 점

- n이 2나 5의 배수인 경우 결과가 존재하지 않음 (문제에서 제외)
- 실제 수를 직접 만들면 `int` 또는 `long` 범위를 초과하므로 **나머지 연산만**으로 해결해야 함
- 나머지를 계속 누적하면서 계산하면, 메모리와 시간 모두 효율적

---

## 🧠 접근 방법

1. **나머지 연산 기반의 BFS-like 사고**  
   실제 수를 만들지 않고 `num = (num * 10 + 1) % n`을 반복하며 나머지만 추적합니다.

2. **반복 종료 조건**  
   나머지가 0이 되는 순간, 해당 자릿수가 n의 배수를 의미합니다.

3. **입력 처리**  
   여러 줄 입력을 받기 때문에 `Scanner.hasNextInt()`를 활용해 EOF까지 처리합니다.

---

## 💬 느낀점

이 문제는 **단순한 반복문 속에 숨겨진 수학적 아이디어**를 확인할 수 있는 흥미로운 문제였습니다.  
특히 큰 수를 직접 다루지 않고 **나머지 연산만으로 배수 여부를 판별**하는 점이 인상적이었습니다.

또한, 입력이 여러 개일 때 EOF 처리 방식(`hasNextInt()`)도 다시 한번 복습할 수 있었습니다.  
문제 자체는 짧지만, **효율적 사고와 수학적 직관**이 요구된다는 점에서 가치 있는 연습 문제였습니다.
