---
title: "[백준 2961번] 도영이가 만든 맛있는 음식 🍳"
date: 2025-10-27
categories: [Baekjoon, DFS, 완전탐색]
tags: [백준, 완전탐색, DFS, 브루트포스, 조합]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
nav: "c"
---

## 📘 문제 설명

N개의 재료가 주어지고, 각 재료마다 **신맛(S)**과 **쓴맛(B)** 값이 있다.  
한 개 이상의 재료를 사용하여 요리를 만들 때,  
요리의 전체 **신맛은 곱(S1 × S2 × …)**, **쓴맛은 합(B1 + B2 + …)** 으로 계산된다.

이때, 두 값의 **차이(|S - B|)**가 최소가 되는 경우를 구하는 문제이다.

---

## 💻 전체 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon2961 {
    // 재료의 개수 N
    static int N;

    // 각 재료의 신맛(s)과 쓴맛(b)을 저장할 배열
    static int[] s, b;

    // 신맛과 쓴맛의 최소 차이를 저장할 변수 (초기값은 가장 큰 정수)
    static int min = Integer.MAX_VALUE;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 재료 개수 입력
        N = Integer.parseInt(br.readLine());
        s = new int[N];
        b = new int[N];

        // 각 재료의 신맛(s)과 쓴맛(b)을 입력받음
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            s[i] = Integer.parseInt(st.nextToken()); // 신맛
            b[i] = Integer.parseInt(st.nextToken()); // 쓴맛
        }

        // DFS 탐색 시작 (초기값: 신맛=1, 쓴맛=0, 선택한 재료 개수=0)
        dfs(0, 1, 0, 0);

        // 최소 차이 출력
        System.out.println(min);
    }

    /**
     * 깊이 우선 탐색 (DFS)으로 모든 재료 조합을 확인
     *
     * @param idx 현재 검사 중인 재료 인덱스 (0 ~ N-1)
     * @param S   지금까지 선택한 재료들의 신맛의 곱
     * @param B   지금까지 선택한 재료들의 쓴맛의 합
     * @param cnt 지금까지 선택한 재료의 개수
     */
    static void dfs(int idx, int S, int B, int cnt) {
        // 모든 재료를 다 확인했다면 (기저 조건)
        if (idx == N) {
            // 재료를 하나라도 선택한 경우만 계산
            if (cnt > 0) {
                // 신맛과 쓴맛의 차이 계산
                int diff = Math.abs(S - B);
                // 최소값 갱신
                min = Math.min(min, diff);
            }
            return; // 탐색 종료
        }

        // ----------------------------
        // ① 현재 idx 번째 재료를 선택하는 경우
        //    → 신맛은 곱해지고, 쓴맛은 더해짐
        dfs(idx + 1, S * s[idx], B + b[idx], cnt + 1);

        // ----------------------------
        // ② 현재 idx 번째 재료를 선택하지 않는 경우
        dfs(idx + 1, S, B, cnt);
    }
}

```

---

## ⚙️ 핵심 로직 정리

| 구분        | 설명                                         |
| ----------- | -------------------------------------------- | ----- | --------------------------- |
| DFS 탐색    | 모든 재료 조합을 완전 탐색 (선택 / 비선택)   |
| 재귀 구조   | 각 단계에서 재료를 포함할지 여부 결정        |
| 최소값 비교 |                                              | S - B | 의 최소값을 지속적으로 갱신 |
| 가지치기    | 불필요한 연산은 없지만, cnt == 0인 경우 제외 |

---

## 🧩 주요 메서드 설명

| 메서드명                              | 설명                                                     |
| ------------------------------------- | -------------------------------------------------------- |
| `dfs(int idx, int S, int B, int cnt)` | 깊이 우선 탐색으로 모든 조합을 확인하고 최소 차이를 갱신 |
| `Math.abs()`                          | 신맛과 쓴맛의 차이를 절댓값으로 계산                     |
| `Math.min()`                          | 최소값을 계속 비교하여 갱신                              |

---

## 💾 사용된 자료구조

| 자료구조          | 설명                                     |
| ----------------- | ---------------------------------------- |
| `int[]`           | 각 재료의 신맛(s), 쓴맛(b) 저장          |
| `DFS (재귀 호출)` | 조합을 생성하기 위한 깊이 우선 탐색 구현 |

---

## ⏱️ 시간 복잡도 분석

- 각 재료는 **선택하거나 선택하지 않음(2가지 경우)** → **O(2^N)**
- N ≤ 10이므로 최대 1024번 탐색 → 충분히 빠른 수행 가능

**✔ 전체 시간 복잡도:** `O(2^N)`  
**✔ 공간 복잡도:** `O(N)` (재귀 호출 스택 + 배열)

---

## 💡 접근 방법

1. **완전 탐색 (Brute Force)** 접근  
   → 재료를 하나씩 선택/비선택하며 가능한 모든 조합 탐색

2. **DFS 재귀 구조 활용**  
   → 각 단계에서 재료를 포함하거나 포함하지 않는 두 가지 선택

3. **차이 계산 시점 제어**  
   → 모든 재료를 탐색한 후(`idx == N`) 재료를 하나라도 선택한 경우에만 계산

4. **최소값 갱신**  
   → `min = Math.min(min, Math.abs(S - B));` 로 최소 차이 갱신

---

## 💬 느낀점

이 문제는 **완전탐색(Brute Force)**와 **DFS(깊이 우선 탐색)**을 함께 활용하는 대표적인 조합 문제였습니다.  
특히, ‘곱’과 ‘합’을 동시에 다루며 각각의 연산 결과를 조합별로 추적해야 하는 점이 인상 깊었습니다.

처음에는 단순 조합 문제처럼 보였지만,  
재귀 호출 구조를 명확히 이해하고 **기저 조건(`idx == N`)**을 잘 설정해야만 올바른 결과가 나옵니다.

이 문제를 통해 **재귀적 사고와 조합 탐색의 구조적 패턴**을 더 깊이 이해할 수 있었습니다.

---
