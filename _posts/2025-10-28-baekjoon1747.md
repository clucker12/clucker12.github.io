---
title: "[백준 1747번] 소수 & 팰린드롬 🔢"
date: 2025-10-28
categories: [Baekjoon, Math, BruteForce]
tags: [백준, 브루트포스, 소수, 팰린드롬, 자바]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 💡 백준 1747번 — 소수 & 팰린드롬

---

## 🧩 문제 개요

입력으로 **자연수 N**이 주어졌을 때,  
`N 이상`인 수 중에서 **소수이면서 동시에 팰린드롬인 수**를 찾아 출력하는 문제입니다.

- 문제 링크: [https://www.acmicpc.net/problem/1747](https://www.acmicpc.net/problem/1747)

---

## 🧠 접근 방법

1. **N부터 시작해서** 하나씩 증가시키며 탐색합니다.
2. 각 수가 **소수인지**, **팰린드롬인지** 검사합니다.
3. 두 조건을 모두 만족하면 바로 출력 후 종료합니다.

→ 브루트포스 접근이지만,  
 문제의 입력 제한(최대 1,000,000 이하)에서는 충분히 빠릅니다.

---

## 💻 전체 코드

```java
package Baekjoon;

import java.util.Scanner;

public class baekjoon1747 {
    static int N; // 입력받은 수를 저장할 전역 변수

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt(); // 사용자로부터 정수 N 입력받기

        // N부터 시작해서, 팰린드롬이면서 소수인 수를 찾을 때까지 반복
        while (true) {
            // isPalindrome(N): N이 팰린드롬인지 확인
            // isPrime(N): N이 소수인지 확인
            if (isPalindrome(N) && isPrime(N)) {
                // 두 조건을 모두 만족하면 결과 출력 후 종료
                System.out.println(N);
                break;
            }
            N++; // 조건을 만족하지 않으면 N을 1 증가시켜 계속 탐색
        }
    }

    // 🔹 소수 판별 함수
    static boolean isPrime(int n) {
        // 2보다 작은 수(0, 1)는 소수가 아님
        if (n < 2) return false;

        // √n 까지만 나눠보면 충분 (i*i <= n)
        for (int i = 2; i * i <= n; i++) {
            // 나누어 떨어지면 소수가 아님
            if (n % i == 0) {
                return false;
            }
        }

        // 위 반복을 모두 통과하면 소수임
        return true;
    }

    // 🔹 팰린드롬 판별 함수
    static boolean isPalindrome(int n) {
        int original = n; // 원래 숫자를 저장해둠 (뒤집은 값과 비교용)
        int reversed = 0; // 뒤집은 숫자를 저장할 변수

        // n이 0이 될 때까지 자릿수를 하나씩 뒤집어 더함
        while (n != 0) {
            int digit = n % 10;            // 마지막 자리 숫자 추출
            reversed = reversed * 10 + digit; // 뒤집은 숫자에 추가
            n /= 10;                       // 마지막 자리 제거
        }

        // 원래 숫자와 뒤집은 숫자가 같으면 팰린드롬
        return original == reversed;
    }
}

```

---

## 🧮 사용한 주요 알고리즘 / 자료구조

| 항목          | 내용                                                |
| ------------- | --------------------------------------------------- |
| 자료구조      | 정수형 변수 (`int`)만 사용 — 불필요한 자료구조 없음 |
| 주요 메서드   | `isPrime()`, `isPalindrome()`                       |
| 알고리즘 유형 | 완전 탐색 (Brute Force) + 수학적 판별               |
| 최적화 포인트 | 소수 판별 시 `√n`까지만 검사                        |

---

## ⚙️ 시간 복잡도 분석

| 함수              | 복잡도        | 설명                             |
| ----------------- | ------------- | -------------------------------- |
| `isPrime(n)`      | **O(√n)**     | n의 제곱근까지만 검사            |
| `isPalindrome(n)` | **O(log₁₀n)** | 숫자의 자릿수만큼 반복           |
| 전체 탐색         | **O(k·√n)**   | k = 조건 만족 전까지 검사한 횟수 |

> 💡 실제로 입력이 1,000,000 이하일 때는 빠르게 수행됩니다.

---

## 🧩 주요 메서드 핵심 로직 설명

### 🔹 `isPrime(int n)`

- 2보다 작은 수는 소수가 아니므로 제외.
- 2부터 √n까지 나누어 떨어지는지 확인.
- 하나라도 나누어 떨어지면 소수 ❌, 아니면 소수 ✅.

### 🔹 `isPalindrome(int n)`

- 숫자를 뒤집은 값을 만들어 원래 숫자와 비교.
- 같다면 팰린드롬 ✅.

---

## ✨ 느낀 점 / 회고 (2025-10-28)

이 문제는 **단순한 완전 탐색처럼 보이지만**,  
실제로는 **수학적 최적화(√n 소수 판별)**와  
**문자열을 쓰지 않고 숫자 연산으로 팰린드롬을 확인하는 방법**이 핵심이었습니다.

처음 접근할 때는 `String`으로 변환해 `equals(reverse)`로 비교하려 했지만,  
숫자 연산으로 처리하니 더 효율적이고 깔끔했습니다.

이 문제를 통해 다시 한번

> “기본기(소수 판별, 팰린드롬 체크)는 알고리즘의 근간이다.”  
> 라는 걸 느꼈습니다.

---
