---
title: "[백준 15683] 감시 문제 풀이 - Java"
date: 2025-09-22
categories: [Baekjoon, Java]
tags: [DFS, 백트래킹, 브루트포스, 구현, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 문제 개요

백준 15683번 **감시** 문제는 CCTV가 설치된 사무실에서, CCTV들의 회전 방향을 적절히 설정하여 사각지대를 최소화하는 것이 목표입니다.

- **입력**: 사무실 크기 N×M, 지도 상태 (0: 빈 칸, 6: 벽, 1~5: CCTV)
- **출력**: 사각지대(0)의 최소 개수

---

## 문제 설명

백준 15683번 감시 문제는 다양한 타입의 CCTV가 있는 사무실에서 사각지대를
최소화하는 방향을 찾는 문제입니다. 각 CCTV는 감시할 수 있는 방향이
다르며, 모든 CCTV의 방향을 적절히 선택하여 사각지대(감시되지 않는
영역)를 최소화해야 합니다.

---

## 접근 방법

- 모든 CCTV의 방향 조합을 탐색해야 하므로 **백트래킹(DFS)**을
  사용합니다.
- 각 CCTV의 타입에 따른 가능한 방향 집합을 미리 정의하고, 재귀적으로
  모든 경우를 탐색합니다.
- CCTV 방향을 선택할 때마다 감시되는 영역을 표시하기 위해 **맵
  복사**를 사용합니다.

---

## 핵심 로직 & 자료구조

**핵심로직**

- `dfs(depth, board)`: 현재 CCTV까지의 방향 조합을 적용하며 깊이 탐색.
- `watch(x, y, dir, map)`: 주어진 방향으로 감시 영역을 `-1`로 마킹.
- `cntSpot(map)`: 남은 사각지대(0) 개수 카운트.
- `copyMap(board)`: 2차원 배열 깊은 복사.

**자료구조**

- `int[][] board` : 원본 지도
- `List<CCTV>` : CCTV 좌표와 타입 저장
- `int[][][] directions` : CCTV 종류별 감시 방향 패턴

---

## 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

public class baekjoon15683 {
    static int N, M;
    static int[][] board;
    static List<CCTV> cctvs = new ArrayList<>();
    static int min = Integer.MAX_VALUE;

    static int[] dx = {-1, 0, 1, 0};
    static int[] dy = {0, 1, 0, -1};

    static int[][][] directions = {
        {},
        {{0}, {1}, {2}, {3}},
        {{0, 2}, {1, 3}},
        {{0, 1}, {1, 2}, {2, 3}, {3, 0}},
        {{0, 1, 2}, {1, 2, 3}, {2, 3, 0}, {3, 0, 1}},
        {{0, 1, 2, 3}}
    };

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        board = new int[N][M];

        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < M; j++) {
                board[i][j] = Integer.parseInt(st.nextToken());
                if (board[i][j] >= 1 && board[i][j] <= 5) {
                    cctvs.add(new CCTV(i, j, board[i][j]));
                }
            }
        }
        dfs(0, board);
        System.out.println(min);
    }

    static void dfs(int depth, int[][] board) {
        if (depth == cctvs.size()) {
            min = Math.min(min, cntSpot(board));
            return;
        }
        CCTV cctv = cctvs.get(depth);
        int type = cctv.type;
        for (int[] dirs : directions[type]) {
            int[][] map = copyMap(board);
            for (int dir : dirs) {
                watch(cctv.x, cctv.y, dir, map);
            }
            dfs(depth + 1, map);
        }
    }

    static void watch(int x, int y, int dir, int[][] map) {
        int nx = x + dx[dir];
        int ny = y + dy[dir];
        while (0 <= nx && nx < N && 0 <= ny && ny < M && map[nx][ny] != 6) {
            if (map[nx][ny] == 0) map[nx][ny] = -1;
            nx += dx[dir];
            ny += dy[dir];
        }
    }

    static int cntSpot(int[][] map) {
        int cnt = 0;
        for (int[] row : map) {
            for (int val : row) {
                if (val == 0) cnt++;
            }
        }
        return cnt;
    }

    static int[][] copyMap(int[][] board) {
        int[][] newMap = new int[N][M];
        for (int i = 0; i < N; i++) {
            newMap[i] = board[i].clone();
        }
        return newMap;
    }

    static class CCTV {
        int x, y, type;
        CCTV(int x, int y, int type) {
            this.x = x;
            this.y = y;
            this.type = type;
        }
    }
}
```

---

## 시간 복잡도

- CCTV가 최대 8개일 때 각 CCTV가 가질 수 있는 방향 조합을 모두 탐색합니다.
- 최악의 경우: O(4\^C) (C = CCTV 개수) \* O(N×M) (감시 영역 표시)
- N,M ≤ 8 이므로 충분히 계산 가능합니다.

---

## 💡 마무리

이 문제는 **완전 탐색**과 **백트래킹**을 적절히 결합해 해결할 수 있습니다.<br>
DFS를 사용해 모든 경우를 탐색하되, 각 단계에서 맵을 복사하여 이전 상태를 유지하는 것이 핵심입니다.

---

## 느낀점

- CCTV의 다양한 감시 방향을 조합하는 과정에서 백트래킹의 진가를 느낄 수 있었던 문제였습니다.
- 처음엔 구현이 복잡해 보였지만, 방향 배열과 맵 복사를 이용하면 깔끔하게 해결할 수 있었습니다.
