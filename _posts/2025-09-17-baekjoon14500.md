---
title: "[백준 14500] - 테트로미노 문제 풀이 - Java 풀이"
date: 2025-09-17
categories: [Baekjoon, Java]
tags: [브루트포스, DFS, 구현, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 문제 설명

N×M 종이 위에 테트로미노를 놓아 그 안에 적힌 수들의 합을 최대로 만드는
문제입니다. DFS로 탐색 가능한 모든 모양을 찾고, DFS로 만들 수 없는
ㅗ,ㅜ,ㅓ,ㅏ 모양을 별도 처리해야 합니다.

## 💻 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon14500 {
    // 종이의 크기 (행: N, 열: M)
    static int N, M;

    // 각 칸에 적힌 숫자
    static int[][] point;

    // DFS 탐색 시 방문 여부 체크용
    static boolean[][] visited;

    // 최대 합을 저장하는 변수
    static int max = 0;

    // 상, 하, 좌, 우 방향 이동
    static int[] dx = {-1, 1, 0, 0};  // x축 방향
    static int[] dy = {0, 0, -1, 1};  // y축 방향

    // DFS로 만들 수 없는 예외 모양 (ㅗ, ㅜ, ㅓ, ㅏ)
    static int[][][] shapes = {
            {{0, 0}, {-1, 0}, {0, -1}, {0, 1}}, // ㅗ
            {{0, 0}, {1, 0}, {0, -1}, {0, 1}},  // ㅜ
            {{0, 0}, {-1, 0}, {1, 0}, {0, -1}}, // ㅓ
            {{0, 0}, {-1, 0}, {1, 0}, {0, 1}}   // ㅏ
    };

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 입력: N(행), M(열)
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        // 배열 초기화
        point = new int[N][M];
        visited = new boolean[N][M];

        // 각 칸에 숫자 입력받기
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < M; j++) {
                point[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        // 모든 좌표에서 테트로미노 하나를 놓는 시도
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                // 시작점 방문 처리 후 DFS 탐색
                visited[i][j] = true;
                dfs(i, j, 1, point[i][j]);
                visited[i][j] = false;

                // DFS로 만들 수 없는 예외 모양 체크 (ㅗ 모양 계열)
                checkExtraShapes(i, j);
            }
        }

        // 최대합 출력
        System.out.println(max);
    }

    // DFS로 깊이 4까지 탐색 (연결된 4칸)
    static void dfs(int x, int y, int depth, int sum) {
        if (depth == 4) {
            // 4칸 다 채웠으면 최대값 갱신
            max = Math.max(sum, max);
            return;
        }

        // 상하좌우 4방향 탐색
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            // 범위 벗어나면 무시
            if (nx < 0 || ny < 0 || nx >= N || ny >= M) {
                continue;
            }

            // 이미 방문한 칸은 무시
            if (visited[nx][ny]) continue;

            // 방문 표시 후 재귀 호출
            visited[nx][ny] = true;
            dfs(nx, ny, depth + 1, sum + point[nx][ny]);
            visited[nx][ny] = false; // 백트래킹
        }
    }

    // DFS로 만들 수 없는 예외 모양들(ㅗ, ㅜ, ㅓ, ㅏ)을 체크
    static void checkExtraShapes(int x, int y) {
        for (int[][] shape : shapes) { // 각 모양에 대해
            int sum = 0;
            boolean isValid = true;

            for (int[] block : shape) { // 각 블록 좌표 확인
                int nx = x + block[0];
                int ny = y + block[1];

                // 종이 밖이면 이 모양은 무시
                if (nx < 0 || ny < 0 || nx >= N || ny >= M) {
                    isValid = false;
                    break;
                }

                // 합산
                sum += point[nx][ny];
            }

            // 유효한 모양일 경우 최대값 갱신
            if (isValid) {
                max = Math.max(max, sum);
            }
        }
    }
}

```

## 🔑 핵심 로직 및 자료구조

- **DFS 탐색**: 4칸을 깊이 우선으로 탐색하여 대부분의 테트로미노
  모양을 탐색.
- **예외 모양 처리**: ㅗ,ㅜ,ㅓ,ㅏ 모양은 DFS로 만들 수 없어 별도의
  좌표 배열(`shapes`)을 두고 합을 계산.
- **visited 배열**: 방문 체크로 경로 중복 방지.
- **dx, dy 배열**: 상하좌우 탐색을 위한 방향 배열.

## 시간 복잡도

- DFS: 각 칸마다 4방향 최대 4\^4의 탐색 → O(N*M*4\^4)
- 예외 모양: 각 칸마다 4개 모양 고정 → O(N\*M)
- 전체: O(N\*M) 내에서 충분히 처리 가능.

## 💡 느낀점

이 문제는 모든 테트로미노를 탐색하기 위해 DFS만으로는 부족하다는 점이
핵심이었습니다. 특히 ㅗ자 모양은 DFS 경로로 표현이 어려워 별도 처리가
필요하다는 아이디어가 중요했습니다. 단순 완전 탐색이지만 모양의 특성을
파악하고 보완하는 사고가 필요했습니다. DFS 백트래킹과 브루트포스의
조합으로 문제를 해결할 수 있었습니다.
