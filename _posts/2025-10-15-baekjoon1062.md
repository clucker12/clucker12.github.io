---
title: "[백준 1062] 가르침 (DFS & 백트래킹) - Java"
date: 2025-10-15
categories: [Baekjoon, Java]
tags: [백트래킹, DFS, 브루트포스, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 💻 백준 1062번 - 가르침

---

## 📘 문제 개요

N개의 단어가 주어지고, K개의 글자를 가르칠 수 있을 때 읽을 수 있는 단어의 최대 개수를 구하는 문제입니다.  
단, 모든 단어는 반드시 `anta`로 시작하고 `tica`로 끝납니다.

---

## 🚀 핵심 아이디어

- **필수 단어 5개(`a, n, t, i, c`)**는 반드시 알아야 함.
- 따라서 **K < 5일 경우 무조건 0개**의 단어만 읽을 수 있음.
- 나머지 K - 5개의 알파벳을 **조합(DFS + 백트래킹)** 으로 선택하여,  
  각 조합마다 읽을 수 있는 단어 수를 계산함.

---

## 🧩 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

public class baekjoon1062 {
    // N: 단어 개수, K: 가르칠 수 있는 글자 수, max: 최대 읽을 수 있는 단어 수
    static int N, K, max = 0;

    // visited[i]: 알파벳 i (0 = a, 25 = z)를 가르쳤는지 여부
    static boolean[] visited = new boolean[26];

    // 전처리된 단어 리스트 ("anta" + (중간) + "tica" → (중간)만 저장)
    static List<String> words = new ArrayList<>();

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 첫 줄 입력 받기: N(단어 수), K(가르칠 수 있는 알파벳 수)
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        K = Integer.parseInt(st.nextToken());

        // 단어 입력 및 "anta", "tica" 제거 후 리스트에 저장
        for (int i = 0; i < N; i++) {
            String word = br.readLine();
            // 모든 단어는 "anta"로 시작하고 "tica"로 끝나므로 중간 부분만 추출
            word = word.substring(4, word.length() - 4);
            words.add(word);
        }

        // 필수 알파벳 5개는 항상 가르쳐야 함
        visited['a' - 'a'] = true;
        visited['n' - 'a'] = true;
        visited['t' - 'a'] = true;
        visited['i' - 'a'] = true;
        visited['c' - 'a'] = true;

        // 가르칠 수 있는 글자가 5개보다 적으면, 필수 글자도 못 배우므로 단어를 읽을 수 없음
        if (K < 5) {
            System.out.println(0);
        } else {
            // 5개는 고정이므로 나머지 K - 5개를 조합으로 선택
            dfs(0, 0);
            System.out.println(max);
        }
    }

    /**
     * DFS를 이용하여 가르칠 수 있는 알파벳 조합을 선택
     * @param index: 알파벳 인덱스 (a=0 ~ z=25), 현재 어떤 알파벳부터 볼지
     * @param depth: 지금까지 선택한 알파벳 개수 (필수 5개 제외한 개수)
     */
    static void dfs(int index, int depth) {
        // K-5개의 알파벳을 선택했다면, 현재 조합으로 몇 개 단어를 읽을 수 있는지 확인
        if (depth == K - 5) {
            max = Math.max(max, countReadableWords());
            return;
        }

        // 알파벳 a(0)부터 z(25)까지 돌면서 아직 선택하지 않은 알파벳을 선택
        for (int i = index; i < 26; i++) {
            if (!visited[i]) {
                visited[i] = true;             // 알파벳 i 선택
                dfs(i + 1, depth + 1);         // 다음 알파벳으로 재귀 호출
                visited[i] = false;            // 백트래킹 (선택 취소)
            }
        }
    }

    /**
     * 현재 가르친 알파벳 조합으로 몇 개의 단어를 읽을 수 있는지 계산
     * @return 읽을 수 있는 단어 수
     */
    static int countReadableWords() {
        int count = 0;

        for (String word : words) {
            boolean readable = true;

            // 단어의 각 글자를 확인해서 가르친 글자인지 체크
            for (int i = 0; i < word.length(); i++) {
                char c = word.charAt(i);
                if (!visited[c - 'a']) {
                    // 가르치지 않은 글자가 있으면 이 단어는 못 읽음
                    readable = false;
                    break;
                }
            }

            // 모든 글자가 가르친 글자라면, 읽을 수 있는 단어로 카운트
            if (readable) count++;
        }

        return count;
    }
}

```

---

## 🧠 주요 메서드 핵심 로직

| 메서드                      | 설명                                                      |
| --------------------------- | --------------------------------------------------------- |
| `dfs(int index, int depth)` | 백트래킹을 통해 가르칠 알파벳 조합을 탐색                 |
| `countReadableWords()`      | 현재 가르친 알파벳 조합으로 읽을 수 있는 단어 개수를 계산 |

---

## 🧮 시간 복잡도

- DFS 조합의 수: **C(26-5, K-5)**
- 각 조합마다 모든 단어를 확인하므로: **O(C(21, K-5) × N × L)**  
  (L = 단어 평균 길이)

최대 경우의 수가 크지만, K ≤ 26이므로 충분히 수행 가능.

---

## 📂 사용 자료구조

| 자료구조            | 역할                                    |
| ------------------- | --------------------------------------- |
| `boolean[] visited` | 알파벳 방문 여부 저장                   |
| `List<String>`      | 단어 리스트 (전처리된 중간 부분만 저장) |

---

## 💡 마무리 & 느낀점

이 문제는 **브루트포스 + 백트래킹의 대표적인 예시**입니다.  
처음 접근할 때는 "모든 알파벳을 어떻게 조합하지?"라는 고민이 있었지만,  
**필수 문자 5개를 제외한 조합 문제**로 바꾸면 훨씬 단순해졌습니다.

문제 해결 과정에서 조합 탐색의 기본 원리를 복습할 수 있었고,  
"필요 없는 부분을 미리 제거하는 전처리"의 중요성도 다시 느꼈습니다. 🌱
