---
title: "[백준 9375] - 패션왕 신해빈 - Java 풀이"
date: 2025-08-06
categories: [Baekjoon, Java]
tags: [해시맵, 조합, 자료구조, 문자열, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 📌 문제 설명

- 각 테스트 케이스에서 의상의 이름과 종류가 주어집니다.
- **조건**: 하루에 최소 한 개 이상의 의상을 입어야 합니다.
- 가능한 모든 의상 조합의 수를 구하세요.

**문제 링크**: [백준 9375 - 패션왕 신해빈](https://www.acmicpc.net/problem/9375)

---

## ✅ 핵심 아이디어

- 의상은 **종류별로 몇 개가 있는지가 중요**합니다.
- 각 의상 종류는 **입을 수도 있고 안 입을 수도 있음** → `(의상 개수 + 1)` 경우의 수.
- 모든 종류에 대해 곱해주고, 마지막에 **아무것도 안 입는 경우 1개를 빼줌**.

---

## ✅ 코드 구현

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;

public class baekjoon9375 {
    public static void main(String[] args)throws IOException {
        // 입력을 빠르게 처리하기 위해 BufferedReader 사용
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 테스트 케이스 수 t 입력
        int t = Integer.parseInt(br.readLine());

        // 각 테스트 케이스 처리
        for(int i = 0; i < t; i++){
            // 현재 테스트 케이스의 의상 개수 n 입력
            int n = Integer.parseInt(br.readLine());

            // 의상 종류별로 몇 개 있는지 저장할 HashMap 생성
            // key: 의상 종류, value: 해당 종류의 의상 개수
            HashMap<String, Integer> cloth = new HashMap<>();

            // n개의 의상 입력 처리
            for(int j = 0; j < n; j++){
                // 한 줄 입력을 공백으로 나누어 [0] = 의상 이름, [1] = 의상 종류
                String[] input = br.readLine().split(" ");
                // 해당 의상 종류의 개수를 1 증가, 없으면 0에서 시작
                cloth.put(input[1], cloth.getOrDefault(input[1], 0) + 1);
            }

            // 모든 조합 수를 계산하기 위한 변수, 1부터 시작
            int result = 1;
            // 각 의상 종류별 선택 가능한 경우 수 계산
            // (해당 종류를 안 입는 경우 1 포함)
            for(int cnt : cloth.values()){
                result *= (cnt + 1);
            }

            // 아무것도 입지 않는 경우(알몸) 제외
            System.out.println(result - 1);
        }
    }
}
```

---

## 🔍 핵심 로직 & 자료구조 설명

### 🟢 HashMap 사용 이유

- key: 의상 종류
- value: 해당 종류의 의상 개수
- getOrDefault(key, defaultValue) → key가 없으면 기본값을 반환.

### 🟠 조합 공식 적용

- 모든 의상 종류에서 (개수 + 1) 곱하기 → 안 입는 경우 포함.
- 마지막에 -1 (모두 안 입는 경우 제거).

---

## 🛠 주요 메서드

| 메서드              | 설명                                          |
| ------------------- | --------------------------------------------- |
| `getOrDefault(k,v)` | key 존재 여부와 상관없이 안전하게 값 가져오기 |
| `split(" ")`        | 문자열을 공백으로 나누기                      |
| `parseInt()`        | 문자열 → 정수 변환                            |

---

## ⏱ 시간 복잡도

- 각 테스트 케이스에서 n개의 의상 입력 처리 → 𝑂(𝑛)

- HashMap을 통해 종류별 개수 관리 → 𝑂(1)

- 최종 곱셈 연산은 종류 개수만큼 반복 → 최대 𝑂(𝑛)
- 총합: 𝑂(𝑛)(입력 개수에 비례)

---

## 💡 마무리 (느낀 점)

- 이 문제는 단순 조합 문제지만, HashMap을 활용하는 사고가 필요합니다.
- 처음에는 조합을 직접 구해야 하나 고민했지만, 종류별 개수 기반 곱셈으로 해결 가능하다는 점이 핵심!

* 알고리즘 접근 포인트:

1. 종류별로 그룹화
2. 안 입는 경우까지 고려
3. 마지막에 -1 (공집합 제거)
