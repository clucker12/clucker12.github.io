---
title: "[백준 1715] - 카드 정렬하기 - Java 풀이"
date: 2025-08-07
categories: [Baekjoon, Java]
tags: [우선순위큐, 그리디, 자료구조, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 📌 문제 설명

숫자 카드 묶음들이 있을 때, **두 묶음을 합치면 그 합만큼 비교 횟수가 발생**합니다.  
**최소한의 비교 횟수로 모든 카드를 하나로 합치려면?**

- 입력: 카드 묶음의 수 N, 이어서 각 카드 묶음의 크기 N개
- 출력: 최소 비교 횟수

[백준 1715 문제 링크](https://www.acmicpc.net/problem/1715)

---

## ✅ 핵심 아이디어

- 가장 적은 비용으로 두 묶음을 반복해서 합쳐야 하므로 **우선순위 큐(Heap)** 를 사용해야 함.
- **항상 가장 작은 두 묶음을 먼저 합치면 최소 비교 횟수**가 됨 → **Greedy(탐욕)** 방식
- 매번 합친 값을 다시 큐에 넣어 반복.

---

## ✅ 코드 구현 (Java)

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;

public class baekjoon1715 {
    public static void main(String[] args)throws IOException {
        // 입력을 받기 위해 BufferedReader 사용
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));

        // 숫자 카드 묶음의 개수 N 입력 받기
        int N = Integer.parseInt(bf.readLine());

        // 우선순위 큐(PriorityQueue)를 사용하여 항상 가장 작은 묶음을 먼저 꺼내기
        PriorityQueue<Integer> pq = new PriorityQueue<>();

        // N개의 숫자 카드 묶음을 우선순위 큐에 삽입
        for(int i=0; i<N; i++){
            int input = Integer.parseInt(bf.readLine());
            pq.offer(input);  // 카드 묶음 크기 저장
        }

        int total = 0;  // 총 비교 횟수를 저장할 변수

        // 카드 묶음이 2개 이상 있을 때만 합치기 가능
        while(pq.size() > 1){
            // 가장 작은 카드 묶음 2개 꺼내기
            int first = pq.poll();
            int second = pq.poll();

            // 두 묶음을 합친다
            int sum = first + second;

            // 합치는 데 사용된 비교 횟수를 누적
            total += sum;

            // 합쳐진 카드 묶음을 다시 우선순위 큐에 삽입
            pq.offer(sum);
        }

        // 최소 비교 횟수 출력
        System.out.println(total);
    }
}

```

---

## 🔍 핵심 로직 & 자료구조 설명

### ✅ 우선순위 큐 사용 이유

| 목적             | 설명                                                |
| ---------------- | --------------------------------------------------- |
| 최소값 우선 접근 | 항상 가장 작은 카드 묶음 2개를 선택해야 하므로 적합 |
| 자동 정렬        | 삽입/삭제마다 자동 정렬됨 (min heap 구조)           |
| 효율성           | 삽입/삭제 모두 \( O(\log N) \) 시간                 |

---

## 🛠 주요 메서드

| 메서드                      | 설명                    |
| --------------------------- | ----------------------- |
| `PriorityQueue.offer(e)`    | 우선순위 큐에 요소 삽입 |
| `PriorityQueue.poll()`      | 가장 작은 값 꺼내기     |
| `BufferedReader.readLine()` | 빠른 입력 처리          |
| `Integer.parseInt()`        | 문자열을 정수로 변환    |

---

## ⏱ 시간 복잡도

- 카드 묶음의 수: N
- 우선순위 큐에 삽입/삭제는 **\( O(\log N) \)**
- N-1번 합치기 진행 → **총 \( O(N \log N) \)**

---

## 💡 마무리 (느낀 점)

이 문제는 전형적인 **Greedy + 우선순위 큐** 조합 문제입니다.  
처음에는 단순히 작은 두 개를 계속 더하면 된다고 생각했지만,  
"**어떻게 효율적으로 계속 작은 값 두 개를 고를 수 있을까?**" 라는 고민이 필요했습니다.

그리디 알고리즘을 사용할 때는,

1. **현재의 선택이 미래에도 최적인가?**
2. **데이터를 어떤 구조에 담아야 이 선택이 효율적으로 가능한가?**  
   를 항상 같이 생각해야 함을 다시 느꼈습니다.

👉 특히, 이 문제처럼 우선순위가 필요한 경우에는 **PriorityQueue를 자연스럽게 연상**할 수 있도록 훈련이 중요합니다.

- Greedy(탐욕법) 알고리즘은 매 순간 가장 좋아 보이는 선택(최적해)을 하는 방식으로 전체 문제의 해결을 시도하는 알고리즘입니다
