---
title: "[백준 17626] Four Squares 문제 풀이 - Java"
date: 2025-10-01
categories: [Baekjoon, Java]
tags: [DP, 다이나믹프로그래밍, 제곱수, 수학, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 🔎 문제 개요

백준 17626번 **Four Squares** 문제는 자연수 N을 **제곱수들의 합**으로 표현할 때 필요한 최소 개수를 구하는 문제입니다.  
이는 **라그랑주의 네 제곱수 정리**와 연결되어 있으며, 모든 자연수는 네 개 이하의 제곱수 합으로 표현 가능하다는 수학적 사실에 기반합니다.

---

## 💡 접근 방법

1. **DP(Dynamic Programming) 활용**

   - `dp[i]`를 "정수 i를 제곱수의 합으로 표현할 수 있는 최소 개수"라고 정의합니다.
   - 초기값: `dp[i] = i` (최악의 경우 모두 `1²`의 합으로 표현).
   - 점화식:
     ```
     dp[i] = min(dp[i], dp[i - j*j] + 1)
     ```
     여기서 `j*j <= i`.

2. **아이디어**
   - 1부터 N까지 차례로 최소 제곱수 개수를 구하면서, 이전 결과(`dp[i - j*j]`)를 활용합니다.
   - 결국 `dp[N]`이 답이 됩니다.

---

## 📜 코드 (Java)

```java
package Baekjoon; // 패키지명 (자바 프로젝트 내에서 파일을 분류하기 위한 이름)

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class baekjoon17626 {
    static int N; // 입력값 N을 저장할 변수

    public static void main(String[] args) throws IOException {
        // 입력을 빠르게 받기 위한 BufferedReader 사용
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 사용자로부터 자연수 N 입력 받기
        N = Integer.parseInt(br.readLine());

        // dp[i]는 숫자 i를 제곱수의 합으로 표현할 수 있는 최소 개수를 의미
        int[] dp = new int[N + 1];

        // 1부터 N까지 각 수에 대해 최소 제곱수 개수 계산
        for (int i = 1; i <= N; i++) {
            // 최악의 경우: 모두 1²로 구성하는 경우 (ex: i=5 → 1+1+1+1+1)
            dp[i] = i;

            // 1², 2², 3², ..., j²가 i 이하일 때 모두 시도
            for (int j = 1; j * j <= i; j++) {
                // i - j² 를 만들 수 있는 최소 제곱수 개수 + 1(= j² 사용)
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }

        // 결과 출력: N을 제곱수 합으로 표현할 수 있는 최소 개수
        System.out.println(dp[N]);
    }
}

```

---

## ⚙️ 주요 로직 & 자료구조 설명

- **`int[] dp`**  
  동적 계획법 배열. `dp[i]`는 i를 제곱수 합으로 표현할 수 있는 최소 개수를 저장.
- **중첩 반복문**
  - 바깥 루프(`i`)는 1부터 N까지 증가
  - 안쪽 루프(`j`)는 `j*j <= i` 조건으로 가능한 모든 제곱수 탐색
- **점화식 적용**
  ```
  dp[i] = min(dp[i], dp[i - j*j] + 1)
  ```
  → 현재 수 `i`에서 제곱수 `j*j`를 사용한 경우와 기존 값 비교

---

## ⏱️ 시간 복잡도

- 바깥 루프: `O(N)`
- 안쪽 루프: 최대 `O(√N)`
- 따라서 전체 시간 복잡도는 **`O(N√N)`**
- N ≤ 50,000 이므로 충분히 통과 가능한 범위입니다.

---

## 💡 마무리 (느낀점)

이 문제는 **DP로 수학 정리를 직접 구현하는 재미**가 있는 문제였습니다.  
특히 "최악의 경우 4개 이하의 제곱수로 표현 가능하다"는 수학적 사실을 코드로 확인할 수 있어 흥미로웠습니다.

접근할 때 단순히 `dp[i] = i`로 초기화 후 하나씩 갱신하는 과정이 핵심이었으며, 제곱수들의 조합을 빠짐없이 확인하는 **브루트포스 + DP 최적화 방식**이 중요했습니다.  
수학적 이론을 프로그래밍적으로 검증하는 과정에서 문제의 깊이를 느낄 수 있었습니다 🚀

---
