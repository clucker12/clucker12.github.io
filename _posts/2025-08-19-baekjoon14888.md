---
title: "[백준 14888] - 연산자 끼워넣기 - Java 풀이"
date: 2025-08-19
categories: [Baekjoon, Java]
tags: [백트래킹, DFS, 완전탐색, 자료구조, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 📘 문제 설명

N개의 수와 N-1개의 연산자가 주어질 때, 주어진 연산자의 개수를 모두 사용하여 만들 수 있는 결과의 **최댓값과 최솟값**을 구하는 문제입니다.

---

# 📂 문제 접근 방법

1. **완전 탐색 필요**

   - N개의 숫자 사이에 (N-1)개의 연산자를 배치하는 모든 경우를 탐색해야 한다.
   - 경우의 수는 연산자 개수 조합에 따라 달라지며, 단순 반복문으로는 불가능하다.

2. **DFS(깊이 우선 탐색)**

   - `dfs(index, result)` 함수로 현재까지 계산된 값과 다음 숫자를 기반으로 탐색을 이어간다.
   - 모든 연산자가 소모될 때까지 재귀적으로 탐색하며, 마지막 단계에서 최대/최소를 갱신한다.

3. **백트래킹(Backtracking)**
   - 연산자를 사용할 때마다 개수를 줄이고, 재귀 호출이 끝나면 다시 복구한다.
   - 불필요한 연산을 줄이고 모든 경우의 수를 **효율적으로 탐색**할 수 있다.

---

# 🧩 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class baekjoon14888 {
    // 변수 선언
    static int N; // 숫자의 개수
    static int[] A; // 숫자 배열 (1부터 시작)
    static int[] operators = new int[5]; // 연산자 개수: [1] +, [2] -, [3] *, [4] /
    static int max = Integer.MIN_VALUE; // 최댓값 초기화
    static int min = Integer.MAX_VALUE; // 최솟값 초기화

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 숫자 개수 입력
        N = Integer.parseInt(br.readLine());
        A = new int[N+1]; // 1-based index를 쓰기 위해 크기를 N+1로

        // 숫자 입력 (A[1] ~ A[N])
        String[] input = br.readLine().split(" ");
        for(int i = 1; i <= N; i++){
            A[i] = Integer.parseInt(input[i-1]);
        }

        // 연산자 개수 입력: + - * /
        String[] op = br.readLine().split(" ");
        for(int i = 1; i <= 4; i++){
            operators[i] = Integer.parseInt(op[i-1]);
        }

        // DFS 탐색 시작 (두 번째 숫자부터, 현재 결과는 A[1])
        dfs(2, A[1]);

        // 결과 출력
        System.out.println(max);
        System.out.println(min);
    }

    // DFS 메서드: index번째 숫자를 계산에 포함시키기 위한 재귀 함수
    public static void dfs(int index, int result){
        // 종료 조건: 모든 숫자를 사용했을 때
        if(index > N){
            max = Math.max(max, result); // 최대값 갱신
            min = Math.min(min, result); // 최소값 갱신
            return;
        }

        // 연산자 4종류에 대해 하나씩 시도
        for(int i = 1; i <= 4; i++){
            if(operators[i] > 0){ // 해당 연산자가 남아 있다면
                operators[i]--; // 연산자 하나 사용

                int next = 0; // 다음 계산 결과 저장용

                // i에 따라 해당 연산 수행
                if(i == 1) next = result + A[index];           // +
                else if(i == 2) next = result - A[index];      // -
                else if(i == 3) next = result * A[index];      // *
                else if(i == 4){                               // /
                    // 음수 나눗셈은 C++14 방식으로 처리
                    if(result < 0){
                        next = -(-result / A[index]);
                    } else {
                        next = result / A[index];
                    }
                }

                // 다음 숫자로 넘어가며 재귀 호출
                dfs(index + 1, next);

                // 백트래킹: 사용한 연산자 복구
                operators[i]++;
            }
        }
    }
}
```

---

# ⏱️ 시간 복잡도

- 모든 연산자 배치를 고려해야 하므로 경우의 수는 **O(4^(N-1))** (최대 탐색)
- 하지만 실제로는 연산자 개수 제한으로 인해 줄어듭니다.
- N ≤ 11 이므로 완전탐색(백트래킹)으로 충분히 해결 가능 ✅

---

# 🔑 주요 메서드 및 자료구조 설명

- **배열 `A`** : 입력된 숫자들을 저장 (1-based index)
- **배열 `operators`** : 연산자 개수 관리 `[+, -, *, /]`
- **DFS (깊이 우선 탐색)** : 가능한 모든 연산자 배치를 시도하며 결과 탐색
- **백트래킹** : 사용한 연산자를 다시 복구하여 다른 경우의 수 탐색

---

# ⚙️ 핵심 로직

- DFS : 모든 경우의 수를 깊이 우선으로 탐색.

- 백트래킹 : 사용한 연산자를 원상 복구하여 다른 경우를 탐색할 수 있도록 한다.

- 연산자 관리 배열 : [+, -, *, /] 개수를 관리하면서 조건문으로 분기 처리.

- 나눗셈 처리 : C++14 기준에 맞춰 음수일 경우 절댓값을 씌워 나누고 부호를 다시 붙여준다.

👉 모든 숫자를 다 사용했을 때, 현재 계산된 결과값으로 **최댓값/최솟값을 갱신**하는 부분이 핵심입니다.
연산자를 하나씩 소모하면서 DFS로 탐색하고, 다시 복구(backtracking)하는 방식으로 모든 경우의 수를 고려합니다.

---

# 💡 백트래킹과 DFS 정리

- DFS (깊이 우선 탐색)
  → 모든 경우의 수를 따라가며 탐색하는 방식.
  → 이 문제에서는 연산자가 남아있는 동안 다음 숫자를 선택하고 결과를 누적하는 역할.

- 백트래킹 (Backtracking)
  → DFS 도중 "조건에 맞지 않거나 탐색이 끝났을 때" 원래 상태로 되돌리는 기법.
  → 이 문제에서는 연산자를 하나 쓰고, 재귀 호출이 끝난 뒤 다시 연산자 개수를 복구하는 과정이 이에 해당한다.

즉, DFS는 탐색 방법, 백트래킹은 탐색 후 원상복구하는 전략이다.
두 개념이 결합되어 완전탐색을 효율적으로 구현할 수 있다.

---

# ✨ 느낀점

이 문제를 풀면서 DFS와 백트래킹이 서로 보완적으로 작동한다는 점을 체감할 수 있었다.
특히 단순 완전 탐색으로는 코드가 복잡해질 수 있는데, 백트래킹을 활용하면 불필요한 중복 탐색을 줄이고 깔끔하게 구현할 수 있었다.

또한 음수 나눗셈 처리 같은 세부적인 구현 요소가 중요한 문제였다.
앞으로 다른 완전 탐색 문제에서도 DFS와 백트래킹을 적극적으로 활용할 수 있을 것 같다.
