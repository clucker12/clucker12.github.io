---
title: "[í”„ë¡œê·¸ë˜ë¨¸ìŠ¤] í¼ì¦ ì¡°ê° ì±„ìš°ê¸° (BFS + íšŒì „ ë§¤ì¹­)"
date: 2025-12-01
categories: [Algorithm, Programmers]
tags: [BFS, ì‹œë®¬ë ˆì´ì…˜, ë„í˜•ë§¤ì¹­, íšŒì „, Java]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true

sidebar:
  nav: "c"
---

# ğŸ§© í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ - í¼ì¦ ì¡°ê° ì±„ìš°ê¸° (Java, BFS + íšŒì „ ë§¤ì¹­)

## ğŸ“Œ ë¬¸ì œ ê°œìš”

ê²Œì„ ë³´ë“œì—ì„œ **ë¹ˆì¹¸(0)** ì„ ì°¾ê³ , í…Œì´ë¸”ì—ì„œ **í¼ì¦ ì¡°ê°(1)** ì„ ì°¾ì•„  
íšŒì „ì„ í¬í•¨í•œ ëª¨ë“  í˜•íƒœë¥¼ ë¹„êµí•˜ì—¬ ë¹ˆì¹¸ì„ ì±„ìš¸ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì¹¸ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œ.

---

## ğŸ§  ì ‘ê·¼ ë°©ë²• ìš”ì•½

### âœ” í•µì‹¬ ì•„ì´ë””ì–´

1. **BFS** ë¡œ ê²Œì„ ë³´ë“œì™€ í…Œì´ë¸”ì—ì„œ ê°ê° ë„í˜•(connected component) ì¶”ì¶œ
2. ë„í˜•ì„ **ì •ê·œí™”(normalize) â†’ íšŒì „(rotate) â†’ ì •ë ¬(sort)**
3. ëª¨ë“  ì¡°ê°ì— ëŒ€í•´ ë¹ˆì¹¸ê³¼ **4ë²ˆ íšŒì „í•˜ì—¬ ëª¨ì–‘ì´ ì¼ì¹˜í•˜ëŠ”ì§€ ë¹„êµ**
4. ì¼ì¹˜í•˜ë©´ í•´ë‹¹ ì¡°ê°ì„ ì‚¬ìš©í•˜ê³  ì •ë‹µ += ë„í˜• í¬ê¸°

---

## ğŸ§© ì‚¬ìš©ëœ ì£¼ìš” ì•Œê³ ë¦¬ì¦˜ & ìë£Œêµ¬ì¡°

- **BFS** : ë„í˜•ì„ êµ¬ì„±í•˜ëŠ” ì—°ê²°ëœ ì¹¸ì„ íƒìƒ‰
- **ë¦¬ìŠ¤íŠ¸(List<int[]> )** : ë„í˜•ì˜ ìƒëŒ€ ì¢Œí‘œ ì €ì¥
- **ì¢Œí‘œ ì •ê·œí™”(normalize)** : ë„í˜•ì„ (0,0)ì„ ê¸°ì¤€ìœ¼ë¡œ ì´ë™
- **íšŒì „ ë³€í™˜** : 90ë„ íšŒì „ (x, y) â†’ (y, -x)
- **ì •ë ¬ & ë¹„êµ** : ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì •ë ¬í•˜ì—¬ ëª¨ì–‘ ë¹„êµ

---

## ğŸ“˜ ì „ì²´ ì½”ë“œ (Java)

```java
package Programmers;
import java.util.*;

public class programmers16 {

    // ë³´ë“œ í¬ê¸°(N x N)
    static int N;

    // ìƒí•˜ì¢Œìš° ì´ë™ ë²¡í„°
    static int[] dx = {1, -1, 0, 0};
    static int[] dy = {0, 0, 1, -1};

    // ë©”ì¸ solution í•¨ìˆ˜
    public int solution(int[][] game_board, int[][] table) {
        N = game_board.length;

        // 1. game_boardì—ì„œ "ë¹ˆì¹¸(0)" ì˜ì—­ë“¤ì„ ëª¨ë‘ ì¶”ì¶œ
        List<List<int[]>> blanks = extractShapes(game_board, 0);

        // 2. tableì—ì„œ "ì¡°ê°(1)" ì˜ì—­ë“¤ì„ ëª¨ë‘ ì¶”ì¶œ
        List<List<int[]>> blocks = extractShapes(table, 1);

        int answer = 0;

        // table ì¡°ê°ì´ ì´ë¯¸ ì‚¬ìš©ë˜ì—ˆëŠ”ì§€ ì²´í¬í•˜ëŠ” ë°°ì—´
        boolean[] used = new boolean[blocks.size()];

        // 3. ë¹ˆì¹¸ë“¤ê³¼ ì¡°ê°ì„ í•˜ë‚˜ì”© ë§¤ì¹­
        for (List<int[]> blank : blanks) {

            // ë¹ˆì¹¸ ì¢Œí‘œë¥¼ ì •ë ¬ (ë¹„êµë¥¼ ìœ„í•´ í•­ìƒ ì •ë ¬ëœ ìƒíƒœ ìœ ì§€)
            Collections.sort(blank, comparator);

            // ëª¨ë“  ì¡°ê°ì„ ìˆœíšŒí•˜ë©° ë§¤ì¹­ë˜ëŠ” ê²ƒ ì°¾ê¸°
            for (int i = 0; i < blocks.size(); i++) {
                if (used[i]) continue;   // ì´ë¯¸ ì‚¬ìš©ëœ ì¡°ê°ì´ë©´ íŒ¨ìŠ¤

                List<int[]> block = blocks.get(i);

                // ì¡°ê° ì¹¸ ê°œìˆ˜ ë‹¤ë¥´ë©´ ì• ì´ˆì— ë¶ˆê°€ëŠ¥
                if (blank.size() != block.size()) continue;

                // íšŒì „ 4ë²ˆ ì‹œë„í•´ì„œ ëª¨ì–‘ì´ ê°™ìœ¼ë©´ ë§¤ì¹­ ì„±ê³µ
                if (match(blank, block)) {
                    used[i] = true;              // ì¡°ê° ì‚¬ìš© ì²˜ë¦¬
                    answer += blank.size();      // ë¹ˆì¹¸ í¬ê¸°ë§Œí¼ ì •ë‹µ ì¦ê°€
                    break;
                }
            }
        }
        return answer;
    }

    // ========================================================
    // boardì—ì„œ target(0 ë˜ëŠ” 1)ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ì—°ê²° ì˜ì—­ì„ ëª¨ë‘ ì¶”ì¶œ
    // ========================================================
    private List<List<int[]>> extractShapes(int[][] board, int target) {
        boolean[][] visited = new boolean[N][N];
        List<List<int[]>> shapes = new ArrayList<>();

        // ë³´ë“œ ì „ì²´ íƒìƒ‰
        for (int x = 0; x < N; x++) {
            for (int y = 0; y < N; y++) {

                // ì•„ì§ ë°©ë¬¸ ì•ˆí–ˆê³  target ê°’ì´ë©´ BFSë¡œ shape ì¶”ì¶œ
                if (!visited[x][y] && board[x][y] == target) {
                    shapes.add(bfs(board, visited, x, y, target));
                }
            }
        }
        return shapes;
    }

    // ========================================================
    // BFSë¡œ í•˜ë‚˜ì˜ ì˜ì—­(ë„í˜•)ì„ ì¶”ì¶œ
    // ========================================================
    private List<int[]> bfs(int[][] board, boolean[][] visited, int sx, int sy, int target) {

        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{sx, sy});
        visited[sx][sy] = true;

        // ë„í˜•ì„ ì´ë£¨ëŠ” ì¢Œí‘œë“¤ì˜ ë¦¬ìŠ¤íŠ¸
        // ì²« ì¢Œí‘œë¥¼ ê¸°ì¤€ì ìœ¼ë¡œ ì‚¼ê¸° ë•Œë¬¸ì— (0,0) ì‹œì‘
        List<int[]> shape = new ArrayList<>();
        shape.add(new int[]{0, 0});

        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int x = cur[0], y = cur[1];

            // ì‚¬ë°© íƒìƒ‰
            for (int d = 0; d < 4; d++) {
                int nx = x + dx[d];
                int ny = y + dy[d];

                // ë²”ìœ„ ë°–ì´ë©´ ê±´ë„ˆë›°ê¸°
                if (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;

                // ë°©ë¬¸ ì•ˆí–ˆê³  target ê°’ì´ë©´ ì˜ì—­ í™•ì¥
                if (!visited[nx][ny] && board[nx][ny] == target) {
                    visited[nx][ny] = true;
                    q.offer(new int[]{nx, ny});

                    // ê¸°ì¤€ì  (sx,sy)ë¡œë¶€í„° ìƒëŒ€ ì¢Œí‘œê°’ ë„£ê¸°
                    shape.add(new int[]{nx - sx, ny - sy});
                }
            }
        }

        // (0,0)ë¶€í„° ì‹œì‘í•˜ë„ë¡ ì •ê·œí™”
        normalize(shape);

        // ì¢Œí‘œ ì •ë ¬ (ë¹„êµë¥¼ ìœ„í•´ í•­ìƒ ì¼ì •í•œ ìˆœì„œ)
        Collections.sort(shape, comparator);

        return shape;
    }

    // ========================================================
    // ë„í˜• ì¢Œí‘œë“¤ì„ (0,0)ì„ ì‹œì‘ì ìœ¼ë¡œ ë§Œë“œëŠ” normalize ê³¼ì •
    // ========================================================
    private void normalize(List<int[]> shape) {

        int minX = Integer.MAX_VALUE;
        int minY = Integer.MAX_VALUE;

        // ê°€ì¥ ì‘ì€ x, y ì°¾ê¸°
        for (int[] p : shape) {
            minX = Math.min(minX, p[0]);
            minY = Math.min(minY, p[1]);
        }

        // ëª¨ë“  ì¢Œí‘œë¥¼ minX, minYë§Œí¼ í‰í–‰ ì´ë™ì‹œí‚¤ê¸°
        for (int[] p : shape) {
            p[0] -= minX;
            p[1] -= minY;
        }
    }

    // ========================================================
    // ë„í˜• 90ë„ íšŒì „ (x,y)->(y,-x)
    // í›„ normalize + sort
    // ========================================================
    private List<int[]> rotate(List<int[]> shape) {

        List<int[]> newShape = new ArrayList<>();

        for (int[] p : shape) {
            // 90ë„ íšŒì „ ê³µì‹
            newShape.add(new int[]{p[1], -p[0]});
        }

        // íšŒì „ í›„ ë‹¤ì‹œ (0,0) ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™”
        normalize(newShape);

        // ë¹„êµë¥¼ ìœ„í•´ ì •ë ¬
        Collections.sort(newShape, comparator);

        return newShape;
    }

    // ========================================================
    // blankì™€ blockì´ íšŒì „ 4ë²ˆ ì¤‘ í•˜ë‚˜ë¼ë„ ê°™ìœ¼ë©´ true
    // ========================================================
    private boolean match(List<int[]> blank, List<int[]> block) {

        List<int[]> temp = block;

        for (int r = 0; r < 4; r++) {   // 0ë„, 90ë„, 180ë„, 270ë„
            if (isSame(blank, temp)) return true;

            // 90ë„ íšŒì „
            temp = rotate(temp);
        }
        return false;
    }

    // ========================================================
    // ë‘ ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸ê°€ ì™„ì „íˆ ê°™ì€ì§€ ë¹„êµ
    // ========================================================
    private boolean isSame(List<int[]> a, List<int[]> b) {

        if (a.size() != b.size()) return false;

        for (int i = 0; i < a.size(); i++) {
            if (a.get(i)[0] != b.get(i)[0] ||
                    a.get(i)[1] != b.get(i)[1])
                return false;
        }
        return true;
    }

    // ========================================================
    // ì¢Œí‘œ ì •ë ¬ ê¸°ì¤€: x ì˜¤ë¦„ì°¨ìˆœ â†’ y ì˜¤ë¦„ì°¨ìˆœ
    // ========================================================
    Comparator<int[]> comparator = (o1, o2) -> {
        if (o1[0] == o2[0]) return o1[1] - o2[1];
        return o1[0] - o2[0];
    };
}

```

---

## ğŸ“ˆ ì‹œê°„ ë³µì¡ë„ ë¶„ì„

âœ” 1) BFSë¡œ ë„í˜• ì¶”ì¶œ

ê° ì¹¸ì„ ìµœëŒ€ í•œ ë²ˆ ë°©ë¬¸ â†’ O(N^2)

âœ” 2) ë„í˜• íšŒì „ ë° ë¹„êµ

- ì¡°ê° ê°œìˆ˜ ìµœëŒ€: ì•½ 6~10ê°œ
- íšŒì „ 4ë²ˆ Ã— ì¢Œí‘œ ì •ë ¬ O(K log K)
- ë¹„êµ: O(K)

ì „ì²´ì ìœ¼ë¡œ
O(NÂ² + P Ã— K log K)
(ë¬¸ì œì˜ Nì´ ì‘ê¸° ë•Œë¬¸ì— ì¶©ë¶„íˆ ë¹ ë¦„)

---

## ğŸ” ì£¼ìš” ë©”ì„œë“œ ì„¤ëª…

1. extractShapes()
   ë³´ë“œ ì „ì²´ë¥¼ ëŒë©° BFSë¡œ ë¹ˆì¹¸/ì¡°ê°ì„ ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ì¶”ì¶œ.

2. bfs()
   ë„í˜• ë‚´ ëª¨ë“  ì¹¸ì„ ìƒëŒ€ ì¢Œí‘œë¡œ ì €ì¥
   â†’ ì´í›„ ë¹„êµë¥¼ ìœ„í•´ normalize + sort ìˆ˜í–‰.

3. normalize()
   ë„í˜•ì„ ì™¼ìª½ ìƒë‹¨(0,0) ê¸°ì¤€ìœ¼ë¡œ ì´ë™í•˜ì—¬
   íšŒì „ í›„ì—ë„ í•­ìƒ ê°™ì€ ì¢Œí‘œê³„ ì‚¬ìš© ê°€ëŠ¥.

4. rotate()
   90ë„ì”© íšŒì „ (x,y) â†’ (y, -x)
   íšŒì „ í›„ normalize + sortë¡œ í‘œì¤€ í˜•íƒœë¡œ ìœ ì§€.

5. match()
   íšŒì „ 4ë²ˆ ì‹œë„í•´ blankì™€ block ëª¨ì–‘ì´ ë™ì¼í•˜ë©´ true.

---

## ğŸ’¡ ëŠë‚€ì  (2025-12-01)

í¼ì¦ ì¡°ê° ë¬¸ì œëŠ” ì–¼í• ë³´ë©´ ë‹¨ìˆœ êµ¬í˜„ ê°™ì§€ë§Œ,
ë„í˜• ì •ê·œí™” â†’ íšŒì „ â†’ ë§¤ì¹­ ë¡œì§ ì´ ì •í™•í•˜ì§€ ì•Šìœ¼ë©´
í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì—ì„œ ì‰½ê²Œ í‹€ë¦¬ëŠ” ë¬¸ì œì˜€ë‹¤.

íŠ¹íˆ normalize ê³¼ì •ì´ í•µì‹¬ì´ë©°,
â€œë„í˜•ì„ ì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ ë¹„êµí•˜ê¸° ìœ„í•´ì„œëŠ”
ì ˆëŒ€ ì¢Œí‘œê°€ ì•„ë‹Œ ìƒëŒ€ ì¢Œí‘œë¡œ í‘œí˜„í•´ì•¼ í•œë‹¤â€
ëŠ” ê°œë…ì„ ë‹¤ì‹œ ìƒê°í•˜ê²Œ ë§Œë“  ë¬¸ì œì˜€ë‹¤.

íšŒì „, ì •ë ¬, ì¢Œí‘œ ì´ë™ì„ ì²´ê³„ì ìœ¼ë¡œ ì¡°í•©í•˜ëŠ” ê²Œ ì¤‘ìš”í–ˆê³ 
êµ¬í˜„ ë‚œë„ê°€ ê½¤ ìˆëŠ” ì‹œë®¬ë ˆì´ì…˜ ë¬¸ì œì˜€ë‹¤ê³  ëŠê¼ˆë‹¤.
