---
title: "[백준 15684] 사다리 조작 문제 풀이 - Java"
date: 2025-10-14
categories: [Baekjoon, Java]
tags: [백트래킹, DFS, 브루트포스, 구현, Java, 백준]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 🎯 백준 15684번 - 사다리 조작 (Java)

---

## 📘 문제 설명

N개의 세로선과 H개의 가로선이 주어진 상태에서, 세로선 i의 출발점이 i번으로 도착하도록 만들기 위해 추가해야 하는 **최소 가로선 수**를 구하는 문제입니다.  
단, 추가할 가로선 수는 최대 3개까지만 가능합니다.

👉 입력 조건:

- N: 세로선 개수 (2 ≤ N ≤ 10)
- M: 이미 존재하는 가로선 개수 (0 ≤ M ≤ 30)
- H: 가로선을 놓을 수 있는 위치 개수 (1 ≤ H ≤ 30)

---

## 🧠 접근 방법

1. **백트래킹(DFS)** 으로 가능한 모든 가로선 추가 조합을 탐색합니다.
2. 매 단계마다 사다리 구조를 완성했는지(`check()` 함수) 검사합니다.
3. i번 세로선이 i번으로 도착하는 조건을 만족하면 최소 가로선 수를 갱신합니다.
4. 가로선을 추가할 때는 인접한 곳에 겹치지 않도록 조건을 검사합니다.

---

## 💻 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon15684 {
    static int N, M, H;                 // N: 세로선 수, M: 가로선 수, H: 가로선 놓을 수 있는 위치 수
    static int min = Integer.MAX_VALUE; // 최소로 추가할 가로선 개수 저장
    static boolean[][] line;            // line[a][b] = true면 a번 줄에 b번 세로선과 b+1번 세로선 사이에 가로선 존재

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 입력: N(세로선 수), M(기존 가로선 수), H(가로선 위치 수)
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        H = Integer.parseInt(st.nextToken());

        // 가로선 배열 초기화 (인덱스 안전하게 H+2 x N+2 크기로 설정)
        line = new boolean[H + 2][N + 2];

        // 기존 가로선 정보 저장
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken()); // 줄 번호 (행)
            int b = Integer.parseInt(st.nextToken()); // 세로선 번호 (열)
            line[a][b] = true; // a번 줄의 b세로선과 b+1세로선을 연결하는 가로선 존재
        }

        // 백트래킹 DFS 시작
        dfs(0, 1, 1);

        // 최소 가로선 수가 3보다 크면 -1 출력 (불가능)
        System.out.println(min > 3 ? -1 : min);
    }

    /**
     * 사다리 결과가 i → i로 연결되는지 확인하는 함수
     */
    static boolean check() {
        // 각 세로선마다 검사
        for (int start = 1; start <= N; start++) {
            int k = start; // 현재 위치 (세로선 번호)

            // 위에서 아래로 내려오며 이동
            for (int i = 1; i <= H; i++) {
                if (line[i][k]) {
                    k++; // 오른쪽 가로선 만나면 오른쪽으로 이동
                } else if (k > 1 && line[i][k - 1]) {
                    k--; // 왼쪽 가로선 만나면 왼쪽으로 이동
                }
            }

            // 시작과 도착이 다르면 실패
            if (k != start) return false;
        }
        return true; // 모두 i → i로 도착하면 true
    }

    /**
     * 백트래킹을 이용한 DFS
     * @param cnt 현재까지 추가한 가로선 개수
     * @param x   가로줄 시작 위치 (줄 번호)
     * @param y   세로선 시작 위치 (열 번호)
     */
    static void dfs(int cnt, int x, int y) {
        // 현재 가로선 개수가 이미 최소값 이상이면 탐색 중단
        if (cnt >= min) return;

        // 유효한 사다리 구조이면 최소값 갱신
        if (check()) {
            min = cnt;
            return;
        }

        // 최대 3개까지만 추가 가능
        if (cnt == 3) return;

        // 가로줄 i를 x부터 H까지 순회
        for (int i = x; i <= H; i++) {
            // j: 세로선 번호 (가로선을 놓을 수 있는 위치는 1~N-1)
            for (int j = 1; j < N; j++) {
                // 현재 위치나 양 옆에 가로선이 이미 있으면 놓을 수 없음
                if (line[i][j] || line[i][j - 1] || line[i][j + 1]) continue;

                // 가로선 추가
                line[i][j] = true;
                dfs(cnt + 1, i, j); // 다음 단계로 탐색
                line[i][j] = false; // 백트래킹: 다시 원상 복구
            }
        }
    }
}

```

---

## 🔍 핵심 로직 요약

| 메서드     | 설명                                   |
| ---------- | -------------------------------------- |
| `check()`  | 사다리 결과가 i → i로 연결되는지 검사  |
| `dfs()`    | 백트래킹으로 가능한 가로선 조합을 탐색 |
| `line[][]` | 가로선 존재 여부를 나타내는 2차원 배열 |

---

## 🧩 주요 자료구조 및 로직

- **`boolean[][] line`**  
  → `line[a][b] = true`이면 a번째 줄의 b번 세로선과 b+1번 세로선 사이에 가로선 존재
- **백트래킹 조건**
  - 현재 위치 혹은 양 옆에 이미 가로선이 있으면 추가 불가
  - 3개 초과 추가 시 탐색 종료
  - 최소 가로선 수 `min` 갱신

---

## ⏱️ 시간 복잡도 분석

- **DFS 깊이 최대:** 3
- **가로선 위치 후보:** H × (N-1) ≤ 30 × 9 = 270
- **최악의 경우:** O(270³) (하지만 백트래킹 조건으로 실제 탐색은 훨씬 적음)

---

## 💡 마무리 및 느낀점

이 문제는 단순한 브루트포스보다는 **효율적인 백트래킹 설계**가 핵심입니다.  
처음에는 모든 조합을 탐색하려다 시간 초과를 우려했지만,  
인접 제약 조건(`line[i][j-1]`, `line[i][j+1]`)을 활용해 가지치기를 하면서 효율이 크게 향상되었습니다.

사다리의 흐름을 직접 따라가며 시뮬레이션하는 과정에서  
**문제의 흐름을 시각적으로 이해하는 능력의 중요성**을 느낄 수 있었습니다.

---
