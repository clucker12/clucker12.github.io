---
title: "[백준 16637번] 괄호 추가하기 💡"
date: 2025-10-31
categories: [Baekjoon, DFS, 완전탐색]
tags: [백준, DFS, 완전탐색, 브루트포스, 수식계산]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## 💡 문제 개요

**문제 번호:** [16637 - 괄호 추가하기](https://www.acmicpc.net/problem/16637)  
**난이도:** 골드 3  
**유형:** DFS / 완전탐색 / 브루트포스

주어진 수식에서 **적절히 괄호를 추가하여 만들 수 있는 최대값**을 구하는 문제입니다.  
단, **괄호 안에는 연산자가 하나만 포함되어야** 하고, **괄호끼리 겹칠 수 없습니다.**

---

## 📘 코드

```java
package Baekjoon;

import java.util.Scanner;

public class baekjoon16637 {
    // 수식의 길이 (항상 홀수)
    static int N;

    // 수식을 문자 배열로 저장 (숫자와 연산자가 번갈아 존재)
    static char[] sik;

    // 결과의 최댓값 (초기값은 최소 정수)
    static int max = Integer.MIN_VALUE;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 입력: 수식의 길이 N
        N = Integer.parseInt(sc.next());
        // 입력: 수식 문자열 (예: "3+8*7-9*2")
        String input = sc.next();

        // 수식을 문자 배열에 저장
        sik = new char[N];
        for (int i = 0; i < N; i++) {
            sik[i] = input.charAt(i);
        }

        // 첫 번째 숫자를 현재 값으로 두고, 두 번째 문자(첫 연산자)부터 탐색 시작
        // 즉, "왼쪽부터 차례로 계산"을 DFS로 시도함
        dfs(1, sik[0] - '0');

        // 최댓값 출력
        System.out.println(max);
    }

    /**
     * DFS 탐색 함수
     * @param idx 현재 처리 중인 연산자의 위치
     * @param current 지금까지 계산된 결과값
     */
    static void dfs(int idx, int current) {
        // [기저 조건] 수식 끝까지 탐색했으면 최댓값 갱신
        if (idx >= N) {
            max = Math.max(max, current);
            return;
        }

        // 현재 연산자
        char op = sik[idx];
        // 다음 숫자
        int nextNum = sik[idx + 1] - '0';

        // ----------------------------------------------------
        // ① 괄호 없이 계산하는 경우
        // ex) current=3, op='+', nextNum=8  → 3+8 = 11
        // 다음 연산자는 idx+2 위치에 있으므로 idx+2로 이동
        // ----------------------------------------------------
        dfs(idx + 2, calc(current, op, nextNum));

        // ----------------------------------------------------
        // ② 괄호를 사용하는 경우 (다음 연산자 포함)
        // ex) 현재 위치가 '+'라면, 다음 연산자('*')와 숫자까지 묶어 "(8*7)" 형태로 먼저 계산
        // 괄호 안에 연산자가 하나만 들어가야 하므로
        // 다음 연산자와 그 뒤 숫자가 모두 있어야 함 → idx+2 < N-1 조건
        // ----------------------------------------------------
        if (idx + 2 < N - 1) {
            // 괄호 안의 결과 계산: (nextNum op2 nextNextNum)
            int bracketVal = calc(nextNum, sik[idx + 2], sik[idx + 3] - '0');
            // 현재 current와 op로, 위 괄호 결과를 이용해 계산
            // ex) current=3, op='+', bracketVal=(8*7)=56 → 3+(8*7)=59
            dfs(idx + 4, calc(current, op, bracketVal));
        }
    }

    /**
     * 실제 계산 수행 함수
     * @param a 첫 번째 피연산자
     * @param op 연산자 (+, -, *)
     * @param b 두 번째 피연산자
     * @return 계산 결과
     */
    static int calc(int a, char op, int b) {
        switch (op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
        }
        return 0; // 이 경우는 사실상 발생하지 않음
    }
}

```

---

## 💡 접근 방법

1. **수식을 문자 배열로 분리**
   - 숫자와 연산자가 번갈아 나타남 → 인덱스 기준으로 `홀수는 연산자`, `짝수는 숫자`
2. **DFS (깊이 우선 탐색)**
   - 괄호를 **넣을지 말지**를 결정하는 완전탐색 문제.
   - 현재 연산자 기준으로 두 가지 선택:
     - 괄호를 안 넣고 바로 계산
     - 괄호를 넣고 `(다음 연산자 포함)` 부분을 먼저 계산
3. **기저 조건**
   - 수식 끝까지 탐색하면 최댓값(`max`) 갱신
4. **계산 로직**
   - `calc(a, op, b)` 함수로 계산 단위를 분리
   - DFS에서 재귀적으로 누적 계산 수행

---

## 🔑 핵심 로직 요약

| 구분              | 설명                                            |
| ----------------- | ----------------------------------------------- |
| **DFS**           | 괄호를 넣을 수 있는 모든 경우를 재귀적으로 탐색 |
| **calc()**        | 연산자에 따라 사칙연산 수행                     |
| **전역 변수 max** | 모든 탐색 중 최댓값을 저장                      |

---

## ⚙️ 시간 복잡도 분석

|항목 |복잡도 |설명 |
|DFS 탐색 |O(2^(N/2)) | 각 연산자 위치마다 괄호를 넣을지 결정 (이진 분기) |
|계산 함수 |O(1) | 단순 사칙연산 |
|전체 |O(2^(N/2)) | 완전탐색 기반이므로 최악의 경우 지수 시간 |

---

## 🧱 사용된 자료구조 및 개념

- char[] 배열: 수식의 문자 단위 저장
- 재귀 (DFS): 괄호 선택의 모든 경우 탐색
- 전역 변수 활용: 최대값을 전역적으로 관리 (max)

---

## 📘 주요 메서드 요약

|메서드 |설명|
|dfs(int idx, int current) |괄호 유무에 따른 분기 탐색|
|calc(int a, char op, int b) |연산자에 따라 계산 수행|

---

## 💬 느낀점 (2025.10.31)

이 문제는 "괄호를 어디에 둘 것인가" 라는 조합적 사고를 요구합니다.
처음엔 단순한 완전탐색이라 생각했지만,
DFS 구조를 통해 모든 경우의 수를 체계적으로 탐색해야 하는 점이 흥미로웠습니다.

또한, 괄호 중첩 불가 조건 때문에 단순 조합이 아닌
인접한 연산자 제약을 고려해야 하는 부분이 어려웠습니다.

이 문제를 통해 다음을 배웠습니다:

- 복잡한 조건의 완전탐색은 DFS로 구조화하면 간결하게 해결할 수 있다.
- 작은 단위(calc)로 로직을 분리하면 가독성이 높아진다.
- 수학적 규칙이 아닌 탐색 전략의 설계력이 핵심이다. 💡
