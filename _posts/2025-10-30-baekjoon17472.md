---
title: "[ë°±ì¤€ 17472ë²ˆ] ë‹¤ë¦¬ ë§Œë“¤ê¸° 2 ğŸŒ‰"
date: 2025-10-30
categories: [Baekjoon, Graph, MST, BFS, Kruskal]
tags: [ë°±ì¤€, ê·¸ë˜í”„, BFS, MST, Kruskal, Union-Find]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

## ğŸ§© ë¬¸ì œ ê°œìš”

**ë¬¸ì œ ë²ˆí˜¸:** [17472 - ë‹¤ë¦¬ ë§Œë“¤ê¸° 2](https://www.acmicpc.net/problem/17472)  
**ìœ í˜•:** ê·¸ë˜í”„ íƒìƒ‰ + ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬(MST)

> NÃ—M í¬ê¸°ì˜ ì§€ë„ì—ì„œ ì„¬ì„ ëª¨ë‘ ì—°ê²°í•˜ê¸° ìœ„í•´ ë‹¤ë¦¬ë¥¼ ë†“ì„ ë•Œ, ë‹¤ë¦¬ì˜ ì´ ê¸¸ì´ì˜ ìµœì†Ÿê°’ì„ êµ¬í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.  
> ë‹¨, ë‹¤ë¦¬ëŠ” ë°”ë‹¤(0) ìœ„ì—ë§Œ ë§Œë“¤ ìˆ˜ ìˆê³ , ê¸¸ì´ëŠ” 2 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.

---

## ğŸ“œ ì½”ë“œ

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class baekjoon17472 {
    static int N, M;                  // ì§€ë„ í¬ê¸° (N: ì„¸ë¡œ, M: ê°€ë¡œ)
    static int[][] board;             // ì§€ë„ ì •ë³´ (0: ë°”ë‹¤, 1: ë•…)
    static boolean[][] visited;       // ì„¬ ë¼ë²¨ë§ ì‹œ ë°©ë¬¸ ì²´í¬
    static int[] dx = {-1, 1, 0, 0};  // ìƒ, í•˜, ì¢Œ, ìš° ì´ë™ ë°©í–¥
    static int[] dy = {0, 0, -1, 1};

    static int islandCount = 2;       // ì„¬ ë²ˆí˜¸ëŠ” 2ë¶€í„° ì‹œì‘ (1ì€ ì›ë˜ ì…ë ¥ê°’)
    static ArrayList<Edge> edges = new ArrayList<>(); // ê°€ëŠ¥í•œ ëª¨ë“  ë‹¤ë¦¬ ëª©ë¡

    static int[] parent;              // Union-Find ë¶€ëª¨ ë°°ì—´

    // ğŸŒ‰ ë‹¤ë¦¬ë¥¼ í‘œí˜„í•˜ëŠ” í´ë˜ìŠ¤
    static class Edge implements Comparable<Edge> {
        int from, to, len; // ì‹œì‘ ì„¬, ë„ì°© ì„¬, ë‹¤ë¦¬ ê¸¸ì´
        Edge(int f, int t, int l) {
            from = f;
            to = t;
            len = l;
        }

        // ë‹¤ë¦¬ ê¸¸ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ (Kruskal ì•Œê³ ë¦¬ì¦˜ìš©)
        public int compareTo(Edge o) {
            return this.len - o.len;
        }
    }

    // âš™ï¸ ë©”ì¸ í•¨ìˆ˜
    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 1ï¸âƒ£ ì…ë ¥ ë°›ê¸°
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());

        board = new int[N][M];
        visited = new boolean[N][M];

        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < M; j++) {
                board[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        // 2ï¸âƒ£ ì„¬ì„ ê°ê° ë²ˆí˜¸ë¡œ ë¼ë²¨ë§
        labelIslands();

        // 3ï¸âƒ£ ê°€ëŠ¥í•œ ëª¨ë“  ë‹¤ë¦¬ í›„ë³´ íƒìƒ‰
        findBridges();

        // 4ï¸âƒ£ MST (Kruskal ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ìµœì†Œ ë‹¤ë¦¬ ê¸¸ì´ í•© êµ¬í•˜ê¸°)
        int answer = kruskal();

        // 5ï¸âƒ£ ê²°ê³¼ ì¶œë ¥ (ë¶ˆê°€ëŠ¥í•˜ë©´ -1)
        System.out.println(answer);
    }

    // ---------------------------------------------------------
    // ğŸï¸ 1. BFSë¡œ ì„¬ ë¼ë²¨ë§
    // ---------------------------------------------------------
    static void labelIslands() {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                // ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë•…ì´ë¼ë©´ ìƒˆë¡œìš´ ì„¬ ì‹œì‘
                if (board[i][j] == 1 && !visited[i][j]) {
                    bfsLabel(i, j, islandCount++); // BFSë¡œ ì—°ê²°ëœ ë•… ëª¨ë‘ ë¼ë²¨ë§
                }
            }
        }
    }

    // BFSë¡œ í•˜ë‚˜ì˜ ì„¬ì„ ëª¨ë‘ ê°™ì€ ë²ˆí˜¸ë¡œ ë°”ê¿”ì¤Œ
    static void bfsLabel(int x, int y, int label) {
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[]{x, y});
        visited[x][y] = true;
        board[x][y] = label; // í•´ë‹¹ ìœ„ì¹˜ë¥¼ ì„¬ ë²ˆí˜¸ë¡œ í‘œì‹œ

        while (!q.isEmpty()) {
            int[] cur = q.poll();
            for (int d = 0; d < 4; d++) {
                int nx = cur[0] + dx[d];
                int ny = cur[1] + dy[d];
                // ë²”ìœ„ ë²—ì–´ë‚˜ë©´ ë¬´ì‹œ
                if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
                // ë•…(1)ì´ê³  ì•„ì§ ë°©ë¬¸ ì•ˆí–ˆìœ¼ë©´ ê°™ì€ ì„¬ìœ¼ë¡œ ì²˜ë¦¬
                if (!visited[nx][ny] && board[nx][ny] == 1) {
                    visited[nx][ny] = true;
                    board[nx][ny] = label; // ì„¬ ë²ˆí˜¸ ì§€ì •
                    q.add(new int[]{nx, ny});
                }
            }
        }
    }

    // ---------------------------------------------------------
    // ğŸŒ‰ 2. ê° ì„¬ì—ì„œ ë‹¤ë¥¸ ì„¬ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆëŠ” ë‹¤ë¦¬ ì°¾ê¸°
    // ---------------------------------------------------------
    static void findBridges() {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                // í˜„ì¬ ìœ„ì¹˜ê°€ ì„¬ì˜ ì¼ë¶€ë¼ë©´
                if (board[i][j] >= 2) {
                    int from = board[i][j]; // ì¶œë°œ ì„¬ ë²ˆí˜¸

                    // 4ë°©í–¥ìœ¼ë¡œ ë‹¤ë¦¬ ê±´ì„¤ ì‹œë„
                    for (int d = 0; d < 4; d++) {
                        int len = 0; // ë‹¤ë¦¬ ê¸¸ì´
                        int nx = i + dx[d];
                        int ny = j + dy[d];

                        while (nx >= 0 && ny >= 0 && nx < N && ny < M) {
                            if (board[nx][ny] == from) break; // ê°™ì€ ì„¬ ë§Œë‚˜ë©´ ì¤‘ë‹¨
                            if (board[nx][ny] == 0) { // ë°”ë‹¤ë¼ë©´ ë‹¤ë¦¬ ì—°ì¥
                                len++;
                                nx += dx[d];
                                ny += dy[d];
                                continue;
                            }

                            // ë‹¤ë¥¸ ì„¬ì„ ë§Œë‚¬ì„ ë•Œ ë‹¤ë¦¬ ê¸¸ì´ê°€ 2 ì´ìƒì´ë©´ ìœ íš¨
                            if (len >= 2) {
                                int to = board[nx][ny];
                                edges.add(new Edge(from, to, len));
                            }
                            break; // ì„¬ì„ ë§Œë‚¬ìœ¼ë‹ˆ ì´ ë°©í–¥ì€ ì¤‘ë‹¨
                        }
                    }
                }
            }
        }
    }

    // ---------------------------------------------------------
    // ğŸª¢ 3. MST - Kruskal ì•Œê³ ë¦¬ì¦˜
    // ---------------------------------------------------------
    static int kruskal() {
        parent = new int[islandCount];
        // ê° ì„¬ì˜ ë¶€ëª¨ ì´ˆê¸°í™” (ìê¸° ìì‹ )
        for (int i = 2; i < islandCount; i++) parent[i] = i;

        // ë‹¤ë¦¬ ê¸¸ì´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬
        Collections.sort(edges);

        int result = 0;    // ì´ ë‹¤ë¦¬ ê¸¸ì´
        int connected = 0; // ì—°ê²°ëœ ì„¬ ê°„ì„  ìˆ˜

        // ì§§ì€ ë‹¤ë¦¬ë¶€í„° ì—°ê²° ì‹œë„
        for (Edge e : edges) {
            if (union(e.from, e.to)) { // ë‘ ì„¬ì´ ì•„ì§ ì—°ê²°ë˜ì§€ ì•Šì•˜ë‹¤ë©´
                result += e.len;
                connected++;

                // ëª¨ë“  ì„¬ì´ ì—°ê²°ë˜ë©´ ì¡°ê¸° ì¢…ë£Œ
                if (connected == islandCount - 3) break;
            }
        }

        // ì—°ê²°ëœ ê°„ì„  ìˆ˜ê°€ ë¶€ì¡±í•˜ë©´ ëª¨ë“  ì„¬ì„ ì—°ê²°í•  ìˆ˜ ì—†ìŒ
        if (connected != islandCount - 3) return -1;
        return result;
    }

    // ---------------------------------------------------------
    // ğŸ”— Union-Find (ì„œë¡œì†Œ ì§‘í•©)
    // ---------------------------------------------------------
    static int find(int x) {
        if (parent[x] == x) return x;
        // ê²½ë¡œ ì••ì¶• (ì¬ê·€ë¡œ ë£¨íŠ¸ ì°¾ì•„ì„œ parent ê°±ì‹ )
        return parent[x] = find(parent[x]);
    }

    static boolean union(int a, int b) {
        int pa = find(a);
        int pb = find(b);
        if (pa == pb) return false; // ì´ë¯¸ ê°™ì€ ê·¸ë£¹ì´ë©´ ì—°ê²° ë¶ˆí•„ìš”
        parent[pb] = pa;            // ë‹¤ë¥´ë©´ í•©ì¹¨
        return true;
    }
}

```

---

## âš™ï¸ ì•Œê³ ë¦¬ì¦˜ íë¦„

1. **ì„¬ ë¼ë²¨ë§ (BFS)**  
   BFSë¡œ ì—°ê²°ëœ ë•…(1)ì„ íƒìƒ‰í•˜ë©° ê°ê° ê³ ìœ  ë²ˆí˜¸ë¡œ ë¼ë²¨ë§í•©ë‹ˆë‹¤.

2. **ë‹¤ë¦¬ íƒìƒ‰**  
   ê° ì„¬ì—ì„œ ìƒí•˜ì¢Œìš° ë°©í–¥ìœ¼ë¡œ ë»—ì–´ë‚˜ê°€ë©°, ë‹¤ë¥¸ ì„¬ê³¼ ì—°ê²°ë  ìˆ˜ ìˆëŠ” ìµœì†Œ ë‹¤ë¦¬ë¥¼ ì°¾ìŠµë‹ˆë‹¤.  
   ë‹¤ë¦¬ì˜ ê¸¸ì´ëŠ” `len >= 2` ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ í•˜ë©°, ê°€ëŠ¥í•œ ëª¨ë“  ë‹¤ë¦¬ë¥¼ ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•©ë‹ˆë‹¤.

3. **MST êµ¬ì„± (Kruskal)**  
   Kruskal ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë‹¤ë¦¬ë¥¼ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì—°ê²°í•˜ë©°, Union-Findë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚¬ì´í´ì„ ë°©ì§€í•©ë‹ˆë‹¤.

---

## ğŸ§  ì£¼ìš” ë©”ì„œë“œ ìš”ì•½

| ë©”ì„œë“œëª…             | ì„¤ëª…                           | í•µì‹¬ ìë£Œêµ¬ì¡°   |
| -------------------- | ------------------------------ | --------------- |
| `labelIslands()`     | BFSë¡œ ì„¬ë§ˆë‹¤ ê³ ìœ  ë²ˆí˜¸ ë¶€ì—¬    | Queue           |
| `findBridges()`      | ê° ì„¬ ê°„ ê°€ëŠ¥í•œ ë‹¤ë¦¬ í›„ë³´ íƒìƒ‰ | ArrayList<Edge> |
| `kruskal()`          | MST êµ¬ì„± í›„ ìµœì†Œ ê¸¸ì´ ê³„ì‚°     | Union-Find      |
| `union()` / `find()` | ì„¬ ì—°ê²° ê´€ê³„ ê´€ë¦¬              | ë°°ì—´            |

---

## ğŸ•’ ì‹œê°„ ë³µì¡ë„

| êµ¬ê°„                    | ë³µì¡ë„               |
| ----------------------- | -------------------- |
| BFS ë¼ë²¨ë§              | O(NÃ—M)               |
| ë‹¤ë¦¬ íƒìƒ‰               | O(NÃ—MÃ—4)             |
| MST (ì •ë ¬ + Union-Find) | O(E log E)           |
| **ì´í•©**                | **O(NÃ—M + E log E)** |

---

## ğŸ’¡ í•µì‹¬ í¬ì¸íŠ¸

- **BFS ë¼ë²¨ë§ â†’ ë‹¤ë¦¬ í›„ë³´ íƒìƒ‰ â†’ Kruskal MST**  
  ì„¸ ë‹¨ê³„ë¥¼ ì²´ê³„ì ìœ¼ë¡œ êµ¬ì„±í•´ì•¼ íš¨ìœ¨ì ì¸ í’€ì´ê°€ ê°€ëŠ¥í–ˆìŠµë‹ˆë‹¤.
- ë‹¤ë¦¬ì˜ **ê¸¸ì´ëŠ” ë°˜ë“œì‹œ 2 ì´ìƒ**ì´ì–´ì•¼ í•¨ì„ ë†“ì¹˜ë©´ ì˜¤ë‹µì´ ë°œìƒí•©ë‹ˆë‹¤.
- **Union-Find**ë¥¼ ì´ìš©í•´ MST êµ¬ì„± ì‹œ ì‚¬ì´í´ì„ ë°©ì§€í–ˆìŠµë‹ˆë‹¤.

---

## ğŸ’¬ ëŠë‚€ì 

ì´ ë¬¸ì œëŠ” **ê·¸ë˜í”„ ëª¨ë¸ë§ + MST ì•Œê³ ë¦¬ì¦˜**ì´ ê²°í•©ëœ ê³ ë‚œë„ ë¬¸ì œì˜€ìŠµë‹ˆë‹¤.  
ì´ˆë°˜ì—ëŠ” BFSë¡œ ì„¬ì„ ë¼ë²¨ë§í•˜ëŠ” ë‹¨ê³„ê¹Œì§€ëŠ” ì‰½ê²Œ ë– ì˜¬ë ¸ì§€ë§Œ,  
ë‹¤ë¦¬ í›„ë³´ë¥¼ ìƒì„±í•˜ëŠ” ê³¼ì •ì—ì„œ **ë°©í–¥ë³„ íƒìƒ‰ ì¢…ë£Œ ì¡°ê±´ê³¼ ë‹¤ë¦¬ ê¸¸ì´ ì œì•½**ì„ ë‹¤ë£¨ëŠ” ê²ƒì´ ê¹Œë‹¤ë¡œì› ìŠµë‹ˆë‹¤.

íŠ¹íˆ MST êµ¬ì„± ì‹œ ëª¨ë“  ì„¬ì´ ì—°ê²°ë˜ì§€ ëª»í•˜ëŠ” ê²½ìš°(-1 ë°˜í™˜)ë¥¼ ì²´í¬í•˜ëŠ” ë¶€ë¶„ì´ ì¤‘ìš”í–ˆìŠµë‹ˆë‹¤.  
ì´ ë¬¸ì œë¥¼ í†µí•´ **BFS, Union-Find, Kruskalì˜ ì¡°í•©**ì´ ì–´ë–»ê²Œ ì‹¤ì œ ë¬¸ì œì—ì„œ í™œìš©ë˜ëŠ”ì§€ ë°°ì› ìŠµë‹ˆë‹¤.  
â€˜ì§€ë„ ê¸°ë°˜ ê·¸ë˜í”„ ë¬¸ì œâ€™ë¥¼ í’€ ë•Œ, ê³µê°„ íƒìƒ‰ê³¼ ê·¸ë˜í”„ ì—°ê²° ê°œë…ì„ ëª…í™•íˆ ë¶„ë¦¬í•˜ëŠ” ê²ƒì´ í•µì‹¬ì´ë¼ëŠ” ì ì„ ëŠê¼ˆìŠµë‹ˆë‹¤.
