---
title: "[백준 2615번] 오목"
date: 2025-11-10
categories: [Baekjoon, 구현, 완전탐색]
tags: [백준, Java, 오목, 구현, 알고리즘]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true
sidebar:
  nav: "c"
---

# 🧩 백준 2615번: 오목

> 난이도: Silver I  
> 언어: Java  
> 문제 링크: [https://www.acmicpc.net/problem/2615](https://www.acmicpc.net/problem/2615)

---

## 📜 문제 개요

19x19 바둑판 위에 검은 돌(1)과 흰 돌(2)이 놓여 있다.  
한 줄로 **연속된 같은 색의 돌이 정확히 5개**가 되는 순간이 승리 조건이다.  
단, 6개 이상이 연속되면 승리가 아니다.

---

## 💻 코드

```java
package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class baekjoon2615 {
    // 19x19 바둑판
    static int[][] board = new int[19][19];

    // 탐색 방향 (→, ↓, ↘, ↗)
    static int[] dx = {0, 1, 1, -1};
    static int[] dy = {1, 0, 1, 1};

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 입력: 19줄의 바둑판 상태를 읽어옴
        for (int i = 0; i < 19; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < 19; j++) {
                board[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        // 바둑판 전체 탐색
        for (int i = 0; i < 19; i++) {
            for (int j = 0; j < 19; j++) {

                // 돌이 있는 칸(1 또는 2)일 때만 검사
                if (board[i][j] != 0) {
                    int color = board[i][j]; // 현재 돌 색 (1=검은색, 2=흰색)

                    // 4가지 방향(→, ↓, ↘, ↗) 각각 검사
                    for (int k = 0; k < 4; k++) {
                        // 이전 방향으로 같은 색 돌이 있으면 이미 체크한 줄이므로 스킵
                        int nx = i - dx[k];
                        int ny = j - dy[k];
                        if (inRange(nx, ny) && board[nx][ny] == color) continue;

                        int cnt = 1;  // 현재 돌 포함
                        int x = i;    // 현재 위치
                        int y = j;

                        // 같은 색 돌이 연속되는지 계속 탐색
                        while (true) {
                            x += dx[k];
                            y += dy[k];

                            // 바둑판을 벗어나거나 색이 다르면 중단
                            if (!inRange(x, y) || board[x][y] != color) break;

                            cnt++;  // 연속된 같은 색 돌 개수 증가
                        }

                        // 정확히 5개가 연속된 경우 (승리 조건)
                        if (cnt == 5) {
                            System.out.println(color);              // 승리한 색 출력
                            System.out.println((i+1)+" " +(j+1));   // 시작 위치 출력 (1-based)
                            return;                                 // 프로그램 종료
                        }
                    }
                }
            }
        }

        // 승부가 결정되지 않은 경우
        System.out.println(0);
    }

    // 좌표가 바둑판 범위 내에 있는지 확인하는 함수
    static boolean inRange(int x, int y) {
        return x >= 0 && x < 19 && y >= 0 && y < 19;
    }
}

```

---

## ⚙️ 주요 메서드 및 핵심 로직

| 메서드                  | 설명                                                     |
| :---------------------- | :------------------------------------------------------- |
| `inRange(int x, int y)` | 좌표가 19x19 보드 범위 내에 있는지 확인                  |
| `main()`                | 전체 보드를 순회하며, 돌이 놓인 지점에서 4방향 탐색 수행 |

### 💡 핵심 아이디어

- **중복 탐색 방지**: `(i, j)`가 연속된 돌의 시작점인지 확인하기 위해  
  이전 칸에 같은 색 돌이 있으면 `continue`로 건너뛴다.
- **정확히 5개만** 연속되는지 확인하기 위해 `cnt == 5` 조건만 만족시킨다.  
  즉, 여섯 번째 돌이 이어지면 승리로 인정하지 않는다.
- 4방향(→, ↓, ↘, ↗)만 탐색하면 모든 경우를 커버할 수 있다.

---

## 🧮 시간 복잡도

- **보드 탐색:** 19 × 19 = 361
- **방향 탐색:** 4방향
- **최대 연속 검사:** 최대 5칸 이동

> **O(19² × 4 × 5)** ≈ **O(1)** (상수 수준 — 매우 빠름)

---

## 🧠 사용한 자료구조

- **2차원 배열 (`int[][] board`)** : 바둑판 상태 저장
- **단순 반복문 & 조건문** : 완전 탐색 기반 구현

---

## 🧩 문제 접근 방법

1. 모든 좌표를 순회하며 돌이 있는 위치 찾기
2. 해당 돌을 시작점으로 4가지 방향(→, ↓, ↘, ↗) 탐색
3. 같은 색이 5개 연속되는지 확인
4. 단, 이전 칸이 같은 색이면 이미 확인한 줄이므로 제외
5. 정확히 5개일 때만 승리 처리

---

## 💬 느낀점 (2025.11.10)

처음에는 단순히 "5개 연속"만 찾으면 된다고 생각했지만,  
“**6개 이상이면 안 된다**”는 조건 때문에 꼼꼼한 인덱스 검사가 필요했다.  
이 문제는 완전 탐색의 기본기와 **탐색 중복 제거 로직**의 중요성을 깨닫게 해줬다.  
특히, ‘시작점 판별’이라는 세밀한 조건을 추가하는 것이 얼마나 효율적인지 배웠다.

---
