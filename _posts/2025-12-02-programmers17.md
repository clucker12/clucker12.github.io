---
title: "[프로그래머스] 가장 먼 노드 (BFS 최단거리)"
date: 2025-12-02
categories: [Algorithm, Programmers]
tags: [BFS, 그래프, 최단거리, Java]
layout: single
author_profile: true
read_time: true
share: true
show_tags: true
show_categories: true
toc: true

sidebar:
  nav: "c"
---

# 🛰️ 프로그래머스 - 가장 먼 노드 (Java, BFS 최단거리)

## 📌 문제 설명

1번 노드로부터 **가장 멀리 떨어진 노드가 몇 개인지** 구하는 문제이다.  
그래프는 양방향이며, 간선 정보가 주어진다.  
최소 간선 개수로 이동 가능하므로 **BFS(최단거리 탐색)** 를 그대로 적용할 수 있다.

---

# 🧠 접근 방법 요약

### ✔ 핵심 아이디어

- BFS는 **모든 간선의 비용이 동일할 때 최단거리 보장**
- 1번 노드에서 시작하여 각 노드까지의 거리(`dist[]`)를 BFS로 측정
- `dist[]` 중 가장 큰 거리 = 가장 먼 거리
- 해당 거리와 같은 노드 수가 정답

### ✔ 왜 DFS가 아니라 BFS?

DFS는 깊이는 구할 수 있어도 **최단 거리 보장은 불가능**  
반면 BFS는 레벨(Depth)을 기준으로 넓게 탐색 → 최초 도달이 곧 최단 거리

### ✔ 사용한 자료구조

| 자료구조              | 용도                         |
| --------------------- | ---------------------------- |
| `List<List<Integer>>` | 인접 리스트 그래프 표현      |
| `Queue<Integer>`      | BFS 탐색 순서를 보장하는 큐  |
| `int[] dist`          | 각 노드까지의 최단 거리 저장 |

---

# 📘 전체 코드 (Java, 설명 포함)

```java
package Programmers;

import java.util.*;

public class programmers17 {
    public int solution(int n, int[][] edge) {

        // -----------------------------
        // 1. 그래프를 인접 리스트로 생성
        // -----------------------------
        // 노드 번호가 1 ~ n 이므로 인덱스를 그대로 사용하려면
        // 크기를 n+1 로 만들어야 한다 (0번은 사용하지 않음)
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<>());
        }

        // -----------------------------
        // 2. 간선 정보를 이용해 그래프 연결
        // -----------------------------
        // 양방향 그래프이므로 서로 추가
        for (int[] vertex : edge){
            int a = vertex[0];
            int b = vertex[1];

            graph.get(a).add(b); // a → b 연결
            graph.get(b).add(a); // b → a 연결
        }

        // -----------------------------
        // 3. BFS 준비
        // -----------------------------
        // dist[i] = 1번 노드에서 i번 노드까지의 최단 거리
        int[] dist = new int[n + 1];
        Arrays.fill(dist, -1); // -1은 "아직 방문하지 않음"을 의미한다

        Queue<Integer> q = new LinkedList<>();

        // 시작점은 1번 노드
        dist[1] = 0; // 자기 자신까지의 거리는 0
        q.add(1);

        // -----------------------------
        // 4. BFS 수행하여 최단 거리 계산
        // -----------------------------
        while (!q.isEmpty()) {
            int cur = q.poll(); // 현재 노드 꺼냄

            // 인접한 노드 탐색
            for (int next : graph.get(cur)) {
                // 방문하지 않은 노드라면
                if (dist[next] == -1) {
                    // 현재 노드까지 거리 + 1
                    dist[next] = dist[cur] + 1;
                    q.add(next); // 다음 탐색 큐에 추가
                }
            }
        }

        // -----------------------------
        // 5. 가장 멀리 떨어진 거리(maxDist) 찾기
        // -----------------------------
        int maxDist = 0;
        for (int d : dist) {
            if (d > maxDist) maxDist = d;
        }

        // -----------------------------
        // 6. 가장 먼 거리와 같은 노드 개수 세기
        // -----------------------------
        int answer = 0;
        for (int d : dist) {
            if (d == maxDist) answer++;
        }

        return answer;
    }
}

```

---

## 🔍 주요 메서드 & 핵심 로직 설명

✔ 1. graph 인접 리스트 구성

- 노드 수가 많을 때 List 기반이 훨씬 빠르고 메모리 효율적이다.
- 양방향이므로 a → b, b → a 둘 다 추가.

✔ 2. dist[] 배열의 의미

| 값     | 의미                   |
| ------ | ---------------------- |
| -1     | 아직 방문하지 않음     |
| 0      | 시작 노드(1번)         |
| 1,2,3… | BFS로 계산된 최단 거리 |

✔ 3. BFS로 최단 거리 보장

큐를 사용해 레벨 순서로 탐색하기 때문에,
처음 방문한 순간이 곧 그 노드까지의 최단 거리이다.

✔ 4. 최댓값 거리 찾기

dist[] 전체를 보며 가장 큰 값을 찾는다.
이 값이 "가장 먼 거리"이다.

✔ 5. 동일한 거리 개수 카운트

dist[] 중 maxDist 와 같은 값의 개수를 세면 정답 완성!

---

## 📈 시간 복잡도 분석

| 단계                | 설명                | 시간         |
| ------------------- | ------------------- | ------------ |
| 그래프 생성         | edge 개수 E         | **O(E)**     |
| BFS 탐색            | 모든 노드/간선 탐색 | **O(N + E)** |
| 최대 거리 탐색      | dist 배열 전체 확인 | **O(N)**     |
| 동일 거리 개수 세기 | dist 배열 전체 확인 | **O(N)**     |

▶ 최종 시간 복잡도
O(N+E)
그래프 탐색 문제에서 가장 효율적인 수준이다.

---

## 💡 느낀점

이 문제는 BFS의 장점을 다시 한 번 확실히 느끼게 해줬다.

- "최단거리"라는 단어가 보이면 → BFS 자동 적용
- 인접 리스트 형태가 그래프 문제에서 얼마나 강력한지 재확인
- 방문 배열(dist 배열)의 설계가 문제 해결을 쉽고 명확하게 해줌

특히 dist[] 를 -1로 초기화하는 방식은
방문 여부 + 거리 정보를 한 번에 처리할 수 있어 매우 깔끔했다.

그래프 문제 입문자에게도 BFS의 핵심 개념을 잘 보여주는 문제라고 생각한다.
